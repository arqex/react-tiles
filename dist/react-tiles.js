/*
react-tiles v0.3.2
https://github.com/arqex/react-tiles#readme
MIT: https://github.com/arqex/react-tiles/raw/master/LICENSE
*/
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"), require("react-dom"));
	else if(typeof define === 'function' && define.amd)
		define(["React", "ReactDOM"], factory);
	else if(typeof exports === 'object')
		exports["react-tiles"] = factory(require("react"), require("react-dom"));
	else
		root["react-tiles"] = factory(root["React"], root["ReactDOM"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = __webpack_require__(1);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** multi main\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///multi_main?");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar React = __webpack_require__(2),\n    ReactDom = __webpack_require__(3),\n    TileWrapper = __webpack_require__(4),\n    FloatingWrapper = __webpack_require__(18),\n    TileLink = __webpack_require__(19),\n    Tile = __webpack_require__(5),\n    QueryBuilder = __webpack_require__(20),\n    utils = __webpack_require__(17),\n    UrlParser = __webpack_require__(21),\n    assign = __webpack_require__(7),\n    qs = __webpack_require__(22);\n\n__webpack_require__(26);\n\nvar minSizes = {\n  column: 200, // For column wrappers this is the minimun height of a row\n  row: 320 // For row wrappers this is the minumum width of a column\n};\n\nvar Tiles = React.createClass({\n  displayName: 'Tiles',\n\n  getInitialState: function getInitialState() {\n    var _this = this;\n\n    Tiles.getQueryBuilder = this.getQueryBuilder;\n\n    Tiles.getWrapperInfo = function (id) {\n      return _this.getQueryBuilder().getWrapperInfo(id);\n    };\n\n    // this.setPathFormat();\n\n    this.props.resolver.init(this.props);\n\n    var layout = UrlParser.parse(this.getRoute());\n    console.log(layout);\n    return {\n      layout: layout,\n      floatingBoxes: this.getInitialBoxes(layout),\n      currentLocation: location.href,\n      dimensions: {\n        height: window.innerHeight,\n        width: window.innerWidth\n      },\n      resizing: false,\n      moving: false\n    };\n  },\n\n  render: function render() {\n    var _this2 = this;\n\n    var className = 'tilecontainer';\n    if (this.state.resizing) {\n      className += ' tileresizing';\n    }\n    if (this.state.moving) {\n      className += ' tilemoving';\n    }\n\n    return React.createElement(\n      'div',\n      { className: className },\n      React.createElement(TileWrapper, _extends({}, this.props, {\n        ref: 'wrapper',\n        layout: this.state.layout,\n        dimensions: this.state.dimensions,\n        builder: this.getQueryBuilder(),\n        onResizeStart: function onResizeStart() {\n          return _this2.setState({ resizing: true });\n        },\n        onResizeEnd: function onResizeEnd() {\n          return _this2.setState({ resizing: false });\n        },\n        onMoveStart: this.onMoveStart,\n        movingTile: this.state.moving,\n        minSizes: minSizes\n      })),\n      React.createElement(FloatingWrapper, _extends({}, this.props, {\n        minSizes: minSizes,\n        tiles: this.state.layout.floating,\n        boxes: this.state.floatingBoxes,\n        builder: this.getQueryBuilder(),\n        onResizeStart: this.onResizeStart,\n        onMoveStart: this.onMoveStart,\n        onStopMove: this.onStopMove }))\n    );\n  },\n  componentDidMount: function componentDidMount() {\n    var _this3 = this;\n\n    this.setState({ dimensions: this.calculateDimensions() });\n    window.addEventListener('resize', function () {\n      if (_this3.ticking) {\n        return;\n      }\n      _this3.ticking = true;\n      utils.requestAnimationFrame(function () {\n        _this3.setState({ dimensions: _this3.calculateDimensions() });\n        _this3.ticking = false;\n      });\n    });\n  },\n  calculateDimensions: function calculateDimensions() {\n    var node = ReactDom.findDOMNode(this);\n    return {\n      width: node.clientWidth,\n      height: node.clientHeight\n    };\n  },\n  getRoute: function getRoute() {\n    var route = location.href.split(location.host)[1];\n    if (route.slice(0, 2) == '/#') {\n      route = route.slice(2);\n    }\n    return route;\n  },\n  componentDidUpdate: function componentDidUpdate() {\n    if (this.state.currentLocation !== location.href) {\n      var layout = UrlParser.parse(this.getRoute());\n      console.log(layout);\n      this.setState({\n        layout: layout,\n        currentLocation: location.href,\n        floatingBoxes: this.refreshBoxes(layout)\n      });\n    }\n  },\n  getQueryBuilder: function getQueryBuilder() {\n    var queryBuilder = new QueryBuilder('/');\n    queryBuilder.setLayout(this.state.layout);\n    return queryBuilder;\n  },\n  setPathFormat: function setPathFormat() {\n    var routeParts = location.href.split(location.host);\n    if (routeParts[1] && routeParts[1].slice(0, 2) === '/#') {\n      QueryBuilder.setPathFormat('/#');\n    }\n  },\n\n  onStopMove: function onStopMove(tileData) {\n    var wrapper = this.refs.wrapper.receiveTile(tileData);\n    if (wrapper) {\n      var builder = this.getQueryBuilder(),\n          tileRoute = this.state.layout.floating[tileData.id],\n          wrapperId = wrapper.isNew ? utils.tid(wrapper.type[0]) : wrapper.id;\n\n      builder.remove(tileData.id, true);\n      var type = wrapper.isNew ? wrapper.type : 'tile',\n          route = builder.setTile({\n        tile: tileData.id,\n        route: tileRoute,\n        type: type,\n        wrapper: wrapperId\n      });\n\n      this.props.resolver.navigate(route);\n    }\n\n    this.setState({ moving: false });\n  },\n\n  getInitialBoxes: function getInitialBoxes(layout) {\n    var _this4 = this;\n\n    var boxes = {},\n        i = 0;\n    Object.keys(layout.floating).forEach(function (tileId) {\n      boxes[tileId] = _this4.getInitialBox(i++);\n    });\n    return boxes;\n  },\n\n  refreshBoxes: function refreshBoxes(layout) {\n    var _this5 = this;\n\n    var boxes = {},\n        ids = Object.keys(layout.floating),\n        i = ids.length;\n\n    ids.forEach(function (tileId) {\n      boxes[tileId] = _this5.state.floatingBoxes[tileId] || _this5.getInitialBox(i++);\n    });\n\n    return boxes;\n  },\n\n\n  getInitialBox: function getInitialBox(i) {\n    return {\n      width: 400,\n      height: 300,\n      top: 100 + 50 * i,\n      left: 100 + 50 * i\n    };\n  },\n\n  calculateBox: function calculateBox(start, dockedDimensions) {\n    var playground = this.calculateDimensions(),\n        box = {};\n\n    box.width = Math.min(dockedDimensions.width, playground.width / 2);\n    box.height = Math.min(dockedDimensions.height, playground.height / 2);\n    box.left = start.left - box.width / 2;\n    box.top = start.top - 20;\n\n    return box;\n  },\n\n  onMoveStart: function onMoveStart(e, tile, dimensions) {\n\n    // Only left click and not a control\n    if (e.button || e.target.tagName.toLowerCase() == 'a') return;\n\n    var me = this,\n        start = { left: e.clientX, top: e.clientY },\n        tid = tile.id,\n        isFloating = !!me.state.layout.floating[tid],\n        box = assign({}, isFloating ? me.state.floatingBoxes[tid] : this.calculateBox(start, dimensions)),\n        moveStarted = false,\n        // Flag to not to stop when the movement has started\n    pos = {\n      left: box.left,\n      top: box.top\n    },\n        ticking = false,\n        dragState = { moving: true, currentTile: tid },\n        finished = false,\n        // A flag to prevent reqAnimFrame to move after finish\n    mm,\n        _mu;\n\n    me.setState(dragState);\n\n    window.addEventListener('mousemove', mm = function mm(e) {\n      if (!ticking) {\n        ticking = true;\n        utils.requestAnimationFrame(function () {\n          if (finished) return;\n          var now = { left: e.clientX, top: e.clientY },\n              left = now.left - start.left,\n              top = now.top - start.top,\n              update = {},\n              boxes = assign({}, me.state.floatingBoxes),\n              builder,\n              nextLayout,\n              nextBox;\n          if (moveStarted || Math.abs(left) > 20 || Math.abs(top) > 20) {\n            // We start moving the tile here\n            //\n            if (!isFloating && !moveStarted) {\n              // we are undocking a tile, remove the tile, create the box and\n              // add it to the floating tiles\n              builder = me.getQueryBuilder();\n              builder.remove(tid, true);\n              nextLayout = builder.setTile(assign({}, { tile: tile.id, wrapper: 'floating', route: tile.route }), true, true);\n              update.layout = nextLayout;\n              boxes[tid] = box;\n            }\n\n            moveStarted = true;\n            update.moving = { id: tid, x: e.clientX, y: e.clientY };\n\n            boxes[tid] = assign({}, boxes[tid], {\n              left: pos.left + left,\n              top: pos.top + top\n            });\n            update.floatingBoxes = boxes;\n            me.setState(update);\n          }\n          ticking = false;\n        });\n      }\n    });\n\n    window.addEventListener('mouseup', _mu = function mu(e) {\n      var update = { moving: false },\n          tiles = assign({}, me.state.dimensions);\n\n      var now = { left: e.clientX, top: e.clientY },\n          left = now.left - start.left,\n          top = now.top - start.top;\n\n      if (moveStarted) {\n        var boxes = assign({}, me.state.floatingBoxes);\n        boxes[tid] = assign({}, boxes[tid], {\n          left: pos.left + left,\n          top: pos.top + top\n        });\n        update.floatingBoxes = boxes;\n\n        var wrapper = me.refs.wrapper.receiveTile({ x: e.clientX, y: e.clientY });\n        if (wrapper) {\n          // Some wrapper has catched the tile\n          var builder = me.getQueryBuilder(),\n              tileRoute = me.state.layout.floating[tid],\n              wrapperId = wrapper.isNew ? utils.tid(wrapper.type[0]) : wrapper.id;\n\n          builder.remove(tid, true);\n          var type = wrapper.isNew ? wrapper.type : 'tile',\n              route = builder.setTile({\n            tile: tile.id,\n            route: tileRoute,\n            type: type,\n            wrapper: wrapperId\n          });\n\n          // If we delete the box, the tile will be moved to the origin\n          // position before disappear\n          //  delete update.floatingBoxes[ tid ];\n\n          me.props.resolver.navigate(route);\n        } else if (!isFloating) {\n          // we are undocking a tile, update the url\n          me.props.resolver.navigate(me.getQueryBuilder().layoutToPath(me.state.layout));\n        }\n      }\n\n      finished = true;\n\n      me.setState(update);\n\n      window.removeEventListener('mousemove', mm);\n      window.removeEventListener('mouseup', _mu);\n    });\n  },\n  onResizeStart: function onResizeStart(direction, tid) {\n    var me = this;\n\n    return function (e) {\n      var origin = { left: e.clientX, top: e.clientY },\n          initial = assign({}, me.state.floatingBoxes[tid]),\n          ticking = false,\n          finished = false,\n          // A flag to prevent reqAnimFrame to move after finish\n      directions = {\n        n: direction.indexOf('n') != -1,\n        s: direction.indexOf('s') != -1,\n        e: direction.indexOf('e') != -1,\n        w: direction.indexOf('w') != -1\n      },\n          maxN = origin.top + initial.height - minSizes.column,\n          maxW = origin.left + initial.width - minSizes.row,\n          mm,\n          _mu2;\n\n      me.setState({ moving: true, currentTile: tid });\n      window.addEventListener('mousemove', mm = function mm(e) {\n        if (!ticking) {\n          ticking = true;\n          window.requestAnimationFrame(function () {\n            if (finished) return;\n\n            var floatingBoxes = assign({}, me.state.floatingBoxes),\n                style = assign({}, floatingBoxes[tid]),\n                dim;\n\n            if (directions.e) {\n              style.width = Math.max(initial.width + e.clientX - origin.left, minSizes.row);\n            }\n            if (directions.s) {\n              style.height = Math.max(initial.height + e.clientY - origin.top, minSizes.column);\n            }\n            if (directions.n) {\n              dim = Math.min(maxN, e.clientY);\n              style.height = initial.height + origin.top - dim;\n              style.top = initial.top - origin.top + dim;\n            }\n            if (directions.w) {\n              dim = Math.min(maxW, e.clientX);\n              style.width = initial.width + origin.left - dim;\n              style.left = initial.left - origin.left + dim;\n            }\n\n            floatingBoxes[tid] = style;\n\n            me.setState({ floatingBoxes: floatingBoxes });\n            ticking = false;\n          });\n        }\n      });\n      window.addEventListener('mouseup', _mu2 = function mu(e) {\n        me.setState({ moving: false });\n        window.removeEventListener('mousemove', mm);\n        window.removeEventListener('mouseup', _mu2);\n      });\n    };\n  }\n});\n\nTiles.Link = TileLink;\nTileLink.setManager(Tiles);\nTiles.version = \"0.3.1\";\n\nmodule.exports = Tiles;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/react-tiles.js\n ** module id = 1\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/react-tiles.js?");

/***/ },
/* 2 */
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n/*****************\n ** WEBPACK FOOTER\n ** external {\"root\":\"React\",\"commonjs\":\"react\",\"commonjs2\":\"react\",\"amd\":\"React\"}\n ** module id = 2\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///external_%7B%22root%22:%22React%22,%22commonjs%22:%22react%22,%22commonjs2%22:%22react%22,%22amd%22:%22React%22%7D?");

/***/ },
/* 3 */
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n/*****************\n ** WEBPACK FOOTER\n ** external {\"root\":\"ReactDOM\",\"commonjs\":\"react-dom\",\"commonjs2\":\"react-dom\",\"amd\":\"ReactDOM\"}\n ** module id = 3\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///external_%7B%22root%22:%22ReactDOM%22,%22commonjs%22:%22react-dom%22,%22commonjs2%22:%22react-dom%22,%22amd%22:%22ReactDOM%22%7D?");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar React = __webpack_require__(2),\n    ReactDom = __webpack_require__(3),\n    Tile = __webpack_require__(5),\n    Animate = __webpack_require__(8),\n    utils = __webpack_require__(17);\n\nvar sizeTypes = {\n  column: 'clientHeight',\n  row: 'clientWidth'\n};\n\nvar TileWrapper = React.createClass({\n  displayName: 'TileWrapper',\n\n  getInitialState: function getInitialState() {\n    return {\n      sizes: this.getInitialSizes(this.props.layout.children.length),\n      updatingSizes: false,\n      resizing: false,\n      firstRendering: true,\n      rect: false\n    };\n  },\n  getInitialSizes: function getInitialSizes(count) {\n    var i = 0,\n        sizes = [];\n\n    while (i++ < count) {\n      sizes.push(100 / count);\n    }\n\n    return sizes;\n  },\n\n  render: function render() {\n    var wrapperClass = ['tilewrapper', 'tile' + this.props.layout.type, this.props.layout.id, this.state.updatingSizes ? 'tileResizing' : '', this.state.firstRendering ? 'tileentering' : 'tileentered'].join(' '),\n        dimensions = this.props.dimensions,\n        placeholder = this.getPlaceholder(this.props.movingTile),\n        style;\n\n    if (this.props.layout.type === 'column') {\n      style = {\n        height: dimensions.height,\n        width: this.isNumeric(dimensions.width) ? '100%' : dimensions.width\n      };\n    } else {\n      style = {\n        height: this.isNumeric(dimensions.height) ? dimensions.height : dimensions.height,\n        width: '100%'\n      };\n    }\n\n    if (placeholder) {\n      wrapperClass += ' phwrapper';\n    }\n\n    return React.createElement(\n      Animate,\n      { ref: 'animate', component: 'div', className: wrapperClass, style: style, transitionName: 'tilewrapper' },\n      this.renderChildren(placeholder),\n      this.renderSeparators()\n    );\n  },\n\n  renderChildren: function renderChildren(placeholder) {\n    var me = this,\n        props = this.props,\n        layout = props.layout,\n        sizes = this.state.sizes,\n        i = 0,\n        placeholder = this.getPlaceholder(this.props.movingTile),\n        factor = {\n      column: 1,\n      row: 1\n    };\n\n    if (placeholder) {\n      factor[placeholder] = .8;\n    }\n\n    var children = layout.children.map(function (child) {\n      var Component = child.type === 'tile' ? Tile : TileWrapper,\n          dimensions;\n\n      if (layout.type === 'column') {\n        dimensions = {\n          height: sizes[i++] * factor.row + '%',\n          width: props.dimensions.width\n        };\n      } else if (layout.type === 'row') {\n        dimensions = {\n          height: props.dimensions.height,\n          width: sizes[i++] * factor.column + '%'\n        };\n      } else {\n        dimensions = {\n          height: 100 * factor.row + '%',\n          width: 100 * factor.column + '%'\n        };\n      }\n\n      return React.createElement(Component, _extends({}, props, {\n        layout: child,\n        key: child.id,\n        ref: child.id,\n        dimensions: dimensions,\n        wrapper: layout,\n        resizing: me.state.resizing,\n        movingTile: me.props.movingTile,\n        onMoveStart: me.props.onMoveStart,\n        onResizeStart: me.props.onResizeStart,\n        onResizeEnd: me.props.onResizeEnd }));\n    });\n\n    if (placeholder) {\n      children.push(this.renderPlaceholder(placeholder));\n    }\n\n    return children;\n  },\n  renderSeparators: function renderSeparators() {\n    var separators = [],\n        acc = 0,\n        dim = this.props.layout.type === 'row' ? 'left' : 'top',\n        className = 'separator separator-' + this.props.layout.type,\n        style;\n    for (var i = 0; i < this.state.sizes.length - 1; i++) {\n      style = {};\n      acc += this.state.sizes[i];\n      style[dim] = acc + '%';\n      separators.push(React.createElement('div', { key: 's' + i, className: className, style: style, onMouseDown: this.updateSizesStart.bind(this, i) }));\n    }\n    return separators;\n  },\n\n  renderPlaceholder: function renderPlaceholder(type) {\n    if (type === 'column') {\n      return React.createElement('div', { className: 'tileph rowph', key: 'rph' });\n    } else {\n      return React.createElement('div', { className: 'tileph columnph', key: 'cph' });\n    }\n  },\n\n  getPlaceholder: function getPlaceholder(moving) {\n    if (!moving || !this.state.rect) {\n      return;\n    }\n    var layout = this.props.layout,\n        rect = this.state.rect,\n        colFactor = rect.height / (layout.children.length + 1),\n        rowFactor = rect.width / (layout.children.length + 1);\n\n    if ((layout.type === 'free' || layout.type === 'row') && moving.x >= rect.right - 200 && moving.y >= rect.top && moving.y <= rect.bottom && rowFactor > this.props.minSizes.row) {\n      return 'column';\n    } else if ((layout.type === 'free' || layout.type === 'column') && moving.y >= rect.bottom - 200 && moving.x >= rect.left && moving.x <= rect.right && colFactor > this.props.minSizes.column) {\n      return 'row';\n    }\n  },\n\n  isNumeric: function isNumeric(n) {\n    return parseFloat(n) === n;\n  },\n  calculateSizes: function calculateSizes(separatorIndex, nextPercent) {\n    var updatingSizes = this.state.updatingSizes,\n        sizes = updatingSizes.sizes,\n        nextSizes = new Array(sizes.length),\n        prevPercent = updatingSizes.initialPercent,\n        remaining,\n        i,\n        factor,\n        nextPercentage;\n\n    if (nextPercent < 0 || nextPercent > 100) {\n      return;\n    }\n\n    // We want to respect the minimum size, so let's check the\n    // tiles that are shrinking\n    if (prevPercent > nextPercent) {\n      // Moving left/up\n      remaining = nextPercent;\n      for (i = 0; i <= separatorIndex; i++) {\n        factor = remaining / prevPercent;\n        // Min needed to not to increase the cell with the minPercentage\n        nextPercentage = Math.min(sizes[i], Math.max(sizes[i] * factor, updatingSizes.minPercentage));\n        nextSizes[i] = nextPercentage;\n        remaining -= nextPercentage;\n        prevPercent -= nextPercentage;\n      }\n\n      factor = 100 - nextPercent + remaining - ( /*current remaining*/100 - updatingSizes.initialPercent) /*previous remaning*/;\n      for (i = separatorIndex + 1; i < sizes.length; i++) {\n        if (i == separatorIndex + 1) {\n          nextSizes[i] = sizes[i] + factor;\n        } else {\n          nextSizes[i] = sizes[i];\n        }\n      }\n    } else {\n      // Moving right/down\n      remaining = 100 - nextPercent;\n      prevPercent = 100 - prevPercent;\n      for (i = sizes.length - 1; i > separatorIndex; i--) {\n        factor = remaining / prevPercent;\n\n        // Min needed to not to increase the cell with the minPercentage\n        nextPercentage = Math.min(sizes[i], Math.max(sizes[i] * factor, updatingSizes.minPercentage));\n        nextSizes[i] = nextPercentage;\n        remaining -= nextPercentage;\n        prevPercent -= nextPercentage;\n      }\n\n      factor = nextPercent + remaining - /*current remaining*/updatingSizes.initialPercent /*previous remaining*/;\n      for (i = separatorIndex; i >= 0; i--) {\n        if (i == separatorIndex) {\n          nextSizes[i] = sizes[i] + factor;\n        } else {\n          nextSizes[i] = sizes[i];\n        }\n      }\n    }\n\n    this.setState({ sizes: nextSizes });\n  },\n  updateSizesStart: function updateSizesStart(separatorIndex, e) {\n    var me = this,\n        type = this.props.layout.type,\n        offset = type === 'row' ? 'left' : 'top',\n        size = type === 'row' ? 'width' : 'height',\n        dimension = type === 'row' ? 'clientX' : 'clientY',\n        wrapper = ReactDom.findDOMNode(this).getBoundingClientRect(),\n        updatingSizes = {\n      wrapperOffset: wrapper[offset],\n      wrapperSize: wrapper[size],\n      separatorIndex: separatorIndex,\n      minPercentage: this.props.minSizes[this.props.layout.type] / wrapper[size] * 100,\n      sizes: this.state.sizes,\n      startingPoint: e[dimension],\n      initialPercent: 0\n    },\n        mm,\n        _mu;\n\n    for (var i = 0; i <= separatorIndex; i++) {\n      updatingSizes.initialPercent += this.state.sizes[i];\n    }\n\n    this.props.onResizeStart();\n\n    this.setState({\n      updatingSizes: updatingSizes,\n      resizing: false\n    });\n\n    window.addEventListener('mousemove', mm = function mm(e) {\n      if (me.ticking) return;\n\n      me.ticking = true;\n      utils.requestAnimationFrame(function () {\n        var sizes = me.state.updatingSizes;\n        var nextPercent = (e[dimension] - sizes.wrapperOffset) / sizes.wrapperSize * 100;\n        if (!me.state.resizing && Math.abs(sizes.startingPoint - e[dimension]) > 5) {\n          me.setState({ resizing: true });\n          // console.log( 'Resizing', nextPercent );\n          me.calculateSizes(separatorIndex, nextPercent);\n        } else if (me.state.resizing) {\n          // console.log( nextPercent );\n          me.calculateSizes(separatorIndex, nextPercent);\n        }\n        me.ticking = false;\n      });\n    });\n    window.addEventListener('mouseup', _mu = function mu(e) {\n      me.setState({ updatingSizes: false, resizing: false });\n\n      me.props.onResizeEnd();\n      window.removeEventListener('mousemove', mm);\n      window.removeEventListener('mouseup', _mu);\n    });\n  },\n\n  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {\n    var childrenCount = nextProps.layout.children.length;\n    if (childrenCount !== this.props.layout.children.length) {\n      this.setState({ sizes: this.getInitialSizes(childrenCount), entering: true });\n    }\n  },\n  componentDidMount: function componentDidMount() {\n    var me = this;\n    setTimeout(function () {\n      me.setState({ firstRendering: false });\n    });\n  },\n  componentDidUpdate: function componentDidUpdate(prevProps) {\n    if (prevProps.movingTile && !this.props.movingTile) {\n      this.setState({ rect: false });\n    } else if (!prevProps.movingTile && this.props.movingTile) {\n      this.setState({ rect: ReactDom.findDOMNode(this).getBoundingClientRect() });\n    }\n  },\n  receiveTile: function receiveTile(position) {\n    var type;\n\n    if (type = this.getPlaceholder(position)) {\n      return {\n        id: this.props.layout.id,\n        type: type,\n        isNew: true\n      };\n    };\n\n    var children = this.props.layout.children,\n        i = children.length,\n        id;\n\n    while (i-- > 0) {\n      if (children.type !== 'tile') {\n        if (type = this.refs[children[i].id].getPlaceholder(position)) {\n          return {\n            id: children[i].id,\n            type: children[i].type\n          };\n        }\n      }\n    }\n  }\n});\n\nmodule.exports = TileWrapper;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/TileWrapper.js\n ** module id = 4\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/components/TileWrapper.js?");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar React = __webpack_require__(2),\n    ReactDom = __webpack_require__(3),\n    IframeTile = __webpack_require__(6),\n    assign = __webpack_require__(7);\n\nvar Tile = React.createClass({\n  displayName: 'Tile',\n\n  getInitialState: function getInitialState() {\n    return {\n      firstRendering: true,\n      route: this.props.layout.route,\n      isIframe: false,\n      C: false\n    };\n  },\n  childContextTypes: {\n    tileLayout: React.PropTypes.object,\n    wrapperId: React.PropTypes.string,\n    builder: React.PropTypes.object,\n    resolver: React.PropTypes.object\n  },\n  getChildContext: function getChildContext() {\n    return {\n      tileLayout: this.props.layout,\n      wrapperId: this.props.wrapper.id,\n      builder: this.props.builder,\n      resolver: this.props.resolver\n    };\n  },\n  render: function render() {\n    var _this = this;\n\n    var className = 'singletile ' + this.props.layout.id + ' ' + this.props.wrapper.type + 'singletile',\n        C = this.state.C,\n        content,\n        overlay;\n\n    if (C) {\n      content = React.createElement(C, this.props);\n    }\n\n    if (this.state.firstRendering) {\n      className += ' tileentering';\n    }\n    if (C === IframeTile) {\n      className += ' tileiframe';\n    }\n    if (this.props.isCurrentTile) {\n      className += ' tilecurrent';\n    }\n\n    if (this.state.isIframe) {\n      overlay = React.createElement('div', { className: 'tileiframeOverlay' });\n    }\n\n    return React.createElement(\n      'div',\n      { className: className, style: assign({}, this.props.dimensions), onClick: function onClick() {\n          return _this.onClick();\n        } },\n      React.createElement(\n        'div',\n        { className: 'tilecontrols', onMouseDown: function onMouseDown(e) {\n            return _this.onMoveStart(e);\n          } },\n        React.createElement(\n          'a',\n          { onClick: function onClick() {\n              return _this.closeTile();\n            } },\n          'x'\n        )\n      ),\n      overlay,\n      React.createElement(\n        TileContent,\n        { resizing: this.props.resizing },\n        content\n      ),\n      this.renderResizers()\n    );\n  },\n  componentDidMount: function componentDidMount() {\n    var me = this;\n    setTimeout(function () {\n      me.setState({ firstRendering: false });\n    });\n    this.updateRouteComponent(this.props);\n  },\n\n  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {\n    if (this.state.route !== nextProps.layout.route) {\n      this.updateRouteComponent(nextProps);\n    }\n  },\n\n\n  updateRouteComponent: function updateRouteComponent(props) {\n    var me = this,\n        route = props.layout.route;\n\n    if (route.match(/https?:\\/\\//i)) {\n      return me.setState({ C: IframeTile, isIframe: true });\n    }\n\n    this.props.resolver.resolve(props.layout.route, function (C) {\n      if (me.state.C !== C) {\n        me.setState({\n          C: C,\n          route: route,\n          isIframe: false\n        });\n      }\n    });\n  },\n  closeTile: function closeTile() {\n    var url = this.props.builder.remove(this.props.layout.id);\n    this.props.resolver.navigate(url);\n  },\n  renderResizers: function renderResizers() {\n    var layout = this.props.layout;\n\n    if (layout.type !== 'floating') {\n      return;\n    }\n\n    return React.createElement(\n      'div',\n      { className: 'tileResizers' },\n      React.createElement('div', { className: 'resizer-n', onMouseDown: this.props.onResizeStart('n', layout.id) }),\n      React.createElement('div', { className: 'resizer-e', onMouseDown: this.props.onResizeStart('e', layout.id) }),\n      React.createElement('div', { className: 'resizer-s', onMouseDown: this.props.onResizeStart('s', layout.id) }),\n      React.createElement('div', { className: 'resizer-w', onMouseDown: this.props.onResizeStart('w', layout.id) }),\n      React.createElement('div', { className: 'resizer-nw', onMouseDown: this.props.onResizeStart('nw', layout.id) }),\n      React.createElement('div', { className: 'resizer-ne', onMouseDown: this.props.onResizeStart('ne', layout.id) }),\n      React.createElement('div', { className: 'resizer-se', onMouseDown: this.props.onResizeStart('se', layout.id) }),\n      React.createElement('div', { className: 'resizer-sw', onMouseDown: this.props.onResizeStart('sw', layout.id) })\n    );\n  },\n  onClick: function onClick() {\n    return this.props.onClick && this.props.onClick(this.props.layout.id);\n  },\n  onMoveStart: function onMoveStart(e) {\n    if (this.props.onMoveStart) {\n      this.props.onMoveStart(e, this.props.layout, ReactDom.findDOMNode(this).getBoundingClientRect());\n    }\n  }\n});\n\n// This is a dumb component that prevents the content of a tile to be re-rendered\n// in a tile resize\nvar TileContent = React.createClass({\n  displayName: 'TileContent',\n\n  render: function render() {\n    return React.createElement(\n      'div',\n      { className: 'tilecontent' },\n      this.props.children\n    );\n  },\n  shouldComponentUpdate: function shouldComponentUpdate() {\n    return !this.props.resizing;\n  }\n});\n\nmodule.exports = Tile;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/Tile.js\n ** module id = 5\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/components/Tile.js?");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar React = __webpack_require__(2);\n\nvar IframeTile = React.createClass({\n  displayName: 'IframeTile',\n\n  render: function render() {\n    return React.createElement('iframe', { src: this.props.layout.route });\n  }\n});\n\nmodule.exports = IframeTile;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/IframeTile.js\n ** module id = 6\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/components/IframeTile.js?");

/***/ },
/* 7 */
/***/ function(module, exports) {

	eval("'use strict';\n/* eslint-disable no-unused-vars */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (e) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (Object.getOwnPropertySymbols) {\n\t\t\tsymbols = Object.getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/object-assign/index.js\n ** module id = 7\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/object-assign/index.js?");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	eval("// export this package's api\n'use strict';\n\nmodule.exports = __webpack_require__(9);\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rc-animate/lib/index.js\n ** module id = 8\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/rc-animate/lib/index.js?");

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar _react = __webpack_require__(2);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _ChildrenUtils = __webpack_require__(10);\n\nvar _AnimateChild = __webpack_require__(11);\n\nvar _AnimateChild2 = _interopRequireDefault(_AnimateChild);\n\nvar _util = __webpack_require__(16);\n\nvar _util2 = _interopRequireDefault(_util);\n\nvar defaultKey = 'rc_animate_' + Date.now();\n\nfunction getChildrenFromProps(props) {\n  var children = props.children;\n  if (_react2['default'].isValidElement(children)) {\n    if (!children.key) {\n      return _react2['default'].cloneElement(children, {\n        key: defaultKey\n      });\n    }\n  }\n  return children;\n}\n\nfunction noop() {}\n\nvar Animate = _react2['default'].createClass({\n  displayName: 'Animate',\n\n  propTypes: {\n    component: _react2['default'].PropTypes.any,\n    animation: _react2['default'].PropTypes.object,\n    transitionName: _react2['default'].PropTypes.string,\n    transitionEnter: _react2['default'].PropTypes.bool,\n    transitionAppear: _react2['default'].PropTypes.bool,\n    exclusive: _react2['default'].PropTypes.bool,\n    transitionLeave: _react2['default'].PropTypes.bool,\n    onEnd: _react2['default'].PropTypes.func,\n    onEnter: _react2['default'].PropTypes.func,\n    onLeave: _react2['default'].PropTypes.func,\n    onAppear: _react2['default'].PropTypes.func,\n    showProp: _react2['default'].PropTypes.string\n  },\n\n  getDefaultProps: function getDefaultProps() {\n    return {\n      animation: {},\n      component: 'span',\n      transitionEnter: true,\n      transitionLeave: true,\n      transitionAppear: false,\n      onEnd: noop,\n      onEnter: noop,\n      onLeave: noop,\n      onAppear: noop\n    };\n  },\n\n  getInitialState: function getInitialState() {\n    this.currentlyAnimatingKeys = {};\n    this.keysToEnter = [];\n    this.keysToLeave = [];\n    return {\n      children: (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(this.props))\n    };\n  },\n\n  componentDidMount: function componentDidMount() {\n    var _this = this;\n\n    var showProp = this.props.showProp;\n    var children = this.state.children;\n    if (showProp) {\n      children = children.filter(function (child) {\n        return !!child.props[showProp];\n      });\n    }\n    children.forEach(function (child) {\n      _this.performAppear(child.key);\n    });\n  },\n\n  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {\n    var _this2 = this;\n\n    this.nextProps = nextProps;\n    var nextChildren = (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(nextProps));\n    var props = this.props;\n    // exclusive needs immediate response\n    if (props.exclusive) {\n      Object.keys(this.currentlyAnimatingKeys).forEach(function (key) {\n        _this2.stop(key);\n      });\n    }\n    var showProp = props.showProp;\n    var currentlyAnimatingKeys = this.currentlyAnimatingKeys;\n    // last props children if exclusive\n    var currentChildren = props.exclusive ? (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(props)) : this.state.children;\n    // in case destroy in showProp mode\n    var newChildren = [];\n    if (showProp) {\n      currentChildren.forEach(function (currentChild) {\n        var nextChild = (0, _ChildrenUtils.findChildInChildrenByKey)(nextChildren, currentChild.key);\n        var newChild = undefined;\n        if ((!nextChild || !nextChild.props[showProp]) && currentChild.props[showProp]) {\n          newChild = _react2['default'].cloneElement(nextChild || currentChild, _defineProperty({}, showProp, true));\n        } else {\n          newChild = nextChild;\n        }\n        if (newChild) {\n          newChildren.push(newChild);\n        }\n      });\n      nextChildren.forEach(function (nextChild) {\n        if (!(0, _ChildrenUtils.findChildInChildrenByKey)(currentChildren, nextChild.key)) {\n          newChildren.push(nextChild);\n        }\n      });\n    } else {\n      newChildren = (0, _ChildrenUtils.mergeChildren)(currentChildren, nextChildren);\n    }\n\n    // need render to avoid update\n    this.setState({\n      children: newChildren\n    });\n\n    nextChildren.forEach(function (child) {\n      var key = child.key;\n      if (currentlyAnimatingKeys[key]) {\n        return;\n      }\n      var hasPrev = (0, _ChildrenUtils.findChildInChildrenByKey)(currentChildren, key);\n      if (showProp) {\n        var showInNext = child.props[showProp];\n        if (hasPrev) {\n          var showInNow = (0, _ChildrenUtils.findShownChildInChildrenByKey)(currentChildren, key, showProp);\n          if (!showInNow && showInNext) {\n            _this2.keysToEnter.push(key);\n          }\n        } else if (showInNext) {\n          _this2.keysToEnter.push(key);\n        }\n      } else if (!hasPrev) {\n        _this2.keysToEnter.push(key);\n      }\n    });\n\n    currentChildren.forEach(function (child) {\n      var key = child.key;\n      if (currentlyAnimatingKeys[key]) {\n        return;\n      }\n      var hasNext = (0, _ChildrenUtils.findChildInChildrenByKey)(nextChildren, key);\n      if (showProp) {\n        var showInNow = child.props[showProp];\n        if (hasNext) {\n          var showInNext = (0, _ChildrenUtils.findShownChildInChildrenByKey)(nextChildren, key, showProp);\n          if (!showInNext && showInNow) {\n            _this2.keysToLeave.push(key);\n          }\n        } else if (showInNow) {\n          _this2.keysToLeave.push(key);\n        }\n      } else if (!hasNext) {\n        _this2.keysToLeave.push(key);\n      }\n    });\n  },\n\n  componentDidUpdate: function componentDidUpdate() {\n    if (this.isMounted()) {\n      var keysToEnter = this.keysToEnter;\n      this.keysToEnter = [];\n      keysToEnter.forEach(this.performEnter);\n      var keysToLeave = this.keysToLeave;\n      this.keysToLeave = [];\n      keysToLeave.forEach(this.performLeave);\n    }\n  },\n\n  performEnter: function performEnter(key) {\n    // may already remove by exclusive\n    if (this.refs[key]) {\n      this.currentlyAnimatingKeys[key] = true;\n      this.refs[key].componentWillEnter(this.handleDoneAdding.bind(this, key, 'enter'));\n    }\n  },\n\n  performAppear: function performAppear(key) {\n    if (this.refs[key]) {\n      this.currentlyAnimatingKeys[key] = true;\n      this.refs[key].componentWillAppear(this.handleDoneAdding.bind(this, key, 'appear'));\n    }\n  },\n\n  handleDoneAdding: function handleDoneAdding(key, type) {\n    var props = this.props;\n    delete this.currentlyAnimatingKeys[key];\n    // if update on exclusive mode, skip check\n    if (props.exclusive && props !== this.nextProps) {\n      return;\n    }\n    var currentChildren = (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(props));\n    if (!this.isValidChildByKey(currentChildren, key)) {\n      // exclusive will not need this\n      this.performLeave(key);\n    } else {\n      if (type === 'appear') {\n        if (_util2['default'].allowAppearCallback(props)) {\n          props.onAppear(key);\n          props.onEnd(key, true);\n        }\n      } else {\n        if (_util2['default'].allowEnterCallback(props)) {\n          props.onEnter(key);\n          props.onEnd(key, true);\n        }\n      }\n    }\n  },\n\n  performLeave: function performLeave(key) {\n    // may already remove by exclusive\n    if (this.refs[key]) {\n      this.currentlyAnimatingKeys[key] = true;\n      this.refs[key].componentWillLeave(this.handleDoneLeaving.bind(this, key));\n    }\n  },\n\n  handleDoneLeaving: function handleDoneLeaving(key) {\n    var props = this.props;\n    delete this.currentlyAnimatingKeys[key];\n    // if update on exclusive mode, skip check\n    if (props.exclusive && props !== this.nextProps) {\n      return;\n    }\n    var currentChildren = (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(props));\n    // in case state change is too fast\n    if (this.isValidChildByKey(currentChildren, key)) {\n      this.performEnter(key);\n    } else {\n      if (_util2['default'].allowLeaveCallback(props)) {\n        props.onLeave(key);\n        props.onEnd(key, false);\n      }\n      if (this.isMounted() && !(0, _ChildrenUtils.isSameChildren)(this.state.children, currentChildren, props.showProp)) {\n        this.setState({\n          children: currentChildren\n        });\n      }\n    }\n  },\n\n  isValidChildByKey: function isValidChildByKey(currentChildren, key) {\n    var showProp = this.props.showProp;\n    if (showProp) {\n      return (0, _ChildrenUtils.findShownChildInChildrenByKey)(currentChildren, key, showProp);\n    }\n    return (0, _ChildrenUtils.findChildInChildrenByKey)(currentChildren, key);\n  },\n\n  stop: function stop(key) {\n    delete this.currentlyAnimatingKeys[key];\n    var component = this.refs[key];\n    if (component) {\n      component.stop();\n    }\n  },\n\n  render: function render() {\n    var props = this.props;\n    this.nextProps = props;\n    var stateChildren = this.state.children;\n    var children = null;\n    if (stateChildren) {\n      children = stateChildren.map(function (child) {\n        if (child === null) {\n          return child;\n        }\n        if (!child.key) {\n          throw new Error('must set key for <rc-animate> children');\n        }\n        return _react2['default'].createElement(\n          _AnimateChild2['default'],\n          {\n            key: child.key,\n            ref: child.key,\n            animation: props.animation,\n            transitionName: props.transitionName,\n            transitionEnter: props.transitionEnter,\n            transitionAppear: props.transitionAppear,\n            transitionLeave: props.transitionLeave },\n          child\n        );\n      });\n    }\n    var Component = props.component;\n    if (Component) {\n      return _react2['default'].createElement(\n        Component,\n        this.props,\n        children\n      );\n    }\n    return children[0] || null;\n  }\n});\n\nexports['default'] = Animate;\nmodule.exports = exports['default'];\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rc-animate/lib/Animate.js\n ** module id = 9\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/rc-animate/lib/Animate.js?");

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.toArrayChildren = toArrayChildren;\nexports.findChildInChildrenByKey = findChildInChildrenByKey;\nexports.findShownChildInChildrenByKey = findShownChildInChildrenByKey;\nexports.findHiddenChildInChildrenByKey = findHiddenChildInChildrenByKey;\nexports.isSameChildren = isSameChildren;\nexports.mergeChildren = mergeChildren;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _react = __webpack_require__(2);\n\nvar _react2 = _interopRequireDefault(_react);\n\nfunction toArrayChildren(children) {\n  var ret = [];\n  _react2['default'].Children.forEach(children, function (child) {\n    ret.push(child);\n  });\n  return ret;\n}\n\nfunction findChildInChildrenByKey(children, key) {\n  var ret = null;\n  if (children) {\n    children.forEach(function (child) {\n      if (ret) {\n        return;\n      }\n      if (child.key === key) {\n        ret = child;\n      }\n    });\n  }\n  return ret;\n}\n\nfunction findShownChildInChildrenByKey(children, key, showProp) {\n  var ret = null;\n  if (children) {\n    children.forEach(function (child) {\n      if (child.key === key && child.props[showProp]) {\n        if (ret) {\n          throw new Error('two child with same key for <rc-animate> children');\n        }\n        ret = child;\n      }\n    });\n  }\n  return ret;\n}\n\nfunction findHiddenChildInChildrenByKey(children, key, showProp) {\n  var found = 0;\n  if (children) {\n    children.forEach(function (child) {\n      if (found) {\n        return;\n      }\n      found = child.key === key && !child.props[showProp];\n    });\n  }\n  return found;\n}\n\nfunction isSameChildren(c1, c2, showProp) {\n  var same = c1.length === c2.length;\n  if (same) {\n    c1.forEach(function (child, index) {\n      var child2 = c2[index];\n      if (child.key !== child2.key) {\n        same = false;\n      } else if (showProp && child.props[showProp] !== child2.props[showProp]) {\n        same = false;\n      }\n    });\n  }\n  return same;\n}\n\nfunction mergeChildren(prev, next) {\n  var ret = [];\n\n  // For each key of `next`, the list of keys to insert before that key in\n  // the combined list\n  var nextChildrenPending = {};\n  var pendingChildren = [];\n  prev.forEach(function (child) {\n    if (findChildInChildrenByKey(next, child.key)) {\n      if (pendingChildren.length) {\n        nextChildrenPending[child.key] = pendingChildren;\n        pendingChildren = [];\n      }\n    } else {\n      pendingChildren.push(child);\n    }\n  });\n\n  next.forEach(function (child) {\n    if (nextChildrenPending.hasOwnProperty(child.key)) {\n      ret = ret.concat(nextChildrenPending[child.key]);\n    }\n    ret.push(child);\n  });\n\n  ret = ret.concat(pendingChildren);\n\n  return ret;\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rc-animate/lib/ChildrenUtils.js\n ** module id = 10\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/rc-animate/lib/ChildrenUtils.js?");

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _react = __webpack_require__(2);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = __webpack_require__(3);\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _cssAnimation = __webpack_require__(12);\n\nvar _cssAnimation2 = _interopRequireDefault(_cssAnimation);\n\nvar _util = __webpack_require__(16);\n\nvar _util2 = _interopRequireDefault(_util);\n\nvar transitionMap = {\n  enter: 'transitionEnter',\n  appear: 'transitionAppear',\n  leave: 'transitionLeave'\n};\n\nvar AnimateChild = _react2['default'].createClass({\n  displayName: 'AnimateChild',\n\n  propTypes: {\n    children: _react2['default'].PropTypes.any\n  },\n\n  componentWillUnmount: function componentWillUnmount() {\n    this.stop();\n  },\n\n  componentWillEnter: function componentWillEnter(done) {\n    if (_util2['default'].isEnterSupported(this.props)) {\n      this.transition('enter', done);\n    } else {\n      done();\n    }\n  },\n\n  componentWillAppear: function componentWillAppear(done) {\n    if (_util2['default'].isAppearSupported(this.props)) {\n      this.transition('appear', done);\n    } else {\n      done();\n    }\n  },\n\n  componentWillLeave: function componentWillLeave(done) {\n    if (_util2['default'].isLeaveSupported(this.props)) {\n      this.transition('leave', done);\n    } else {\n      done();\n    }\n  },\n\n  transition: function transition(animationType, finishCallback) {\n    var _this = this;\n\n    var node = _reactDom2['default'].findDOMNode(this);\n    var props = this.props;\n    var transitionName = props.transitionName;\n    this.stop();\n    var end = function end() {\n      _this.stopper = null;\n      finishCallback();\n    };\n    if ((_cssAnimation.isCssAnimationSupported || !props.animation[animationType]) && transitionName && props[transitionMap[animationType]]) {\n      this.stopper = (0, _cssAnimation2['default'])(node, transitionName + '-' + animationType, end);\n    } else {\n      this.stopper = props.animation[animationType](node, end);\n    }\n  },\n\n  stop: function stop() {\n    var stopper = this.stopper;\n    if (stopper) {\n      this.stopper = null;\n      stopper.stop();\n    }\n  },\n\n  render: function render() {\n    return this.props.children;\n  }\n});\n\nexports['default'] = AnimateChild;\nmodule.exports = exports['default'];\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rc-animate/lib/AnimateChild.js\n ** module id = 11\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/rc-animate/lib/AnimateChild.js?");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Event = __webpack_require__(13);\n\nvar _Event2 = _interopRequireDefault(_Event);\n\nvar _componentClasses = __webpack_require__(14);\n\nvar _componentClasses2 = _interopRequireDefault(_componentClasses);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar isCssAnimationSupported = _Event2[\"default\"].endEvents.length !== 0;\n\n\nvar capitalPrefixes = ['Webkit', 'Moz', 'O',\n// ms is special .... !\n'ms'];\nvar prefixes = ['-webkit-', '-moz-', '-o-', 'ms-', ''];\n\nfunction getDuration(node, name) {\n  var style = window.getComputedStyle(node);\n\n  var ret = '';\n  for (var i = 0; i < prefixes.length; i++) {\n    ret = style.getPropertyValue(prefixes[i] + name);\n    if (ret) {\n      break;\n    }\n  }\n  return ret;\n}\n\nfunction fixBrowserByTimeout(node) {\n  if (isCssAnimationSupported) {\n    var transitionDuration = parseFloat(getDuration(node, 'transition-duration')) || 0;\n    var animationDuration = parseFloat(getDuration(node, 'animation-duration')) || 0;\n    var time = Math.max(transitionDuration, animationDuration);\n    // sometimes, browser bug\n    node.rcEndAnimTimeout = setTimeout(function () {\n      node.rcEndAnimTimeout = null;\n      if (node.rcEndListener) {\n        node.rcEndListener();\n      }\n    }, time * 1000 + 200);\n  }\n}\n\nfunction clearBrowserBugTimeout(node) {\n  if (node.rcEndAnimTimeout) {\n    clearTimeout(node.rcEndAnimTimeout);\n    node.rcEndAnimTimeout = null;\n  }\n}\n\nvar cssAnimation = function cssAnimation(node, transitionName, endCallback) {\n  var className = transitionName;\n  var activeClassName = className + '-active';\n  var end = endCallback;\n  var start = void 0;\n  var active = void 0;\n  var nodeClasses = (0, _componentClasses2[\"default\"])(node);\n\n  if (endCallback && Object.prototype.toString.call(endCallback) === '[object Object]') {\n    end = endCallback.end;\n    start = endCallback.start;\n    active = endCallback.active;\n  }\n\n  if (node.rcEndListener) {\n    node.rcEndListener();\n  }\n\n  node.rcEndListener = function (e) {\n    if (e && e.target !== node) {\n      return;\n    }\n\n    if (node.rcAnimTimeout) {\n      clearTimeout(node.rcAnimTimeout);\n      node.rcAnimTimeout = null;\n    }\n\n    clearBrowserBugTimeout(node);\n\n    nodeClasses.remove(className);\n    nodeClasses.remove(activeClassName);\n\n    _Event2[\"default\"].removeEndEventListener(node, node.rcEndListener);\n    node.rcEndListener = null;\n\n    // Usually this optional end is used for informing an owner of\n    // a leave animation and telling it to remove the child.\n    if (end) {\n      end();\n    }\n  };\n\n  _Event2[\"default\"].addEndEventListener(node, node.rcEndListener);\n\n  if (start) {\n    start();\n  }\n  nodeClasses.add(className);\n\n  node.rcAnimTimeout = setTimeout(function () {\n    node.rcAnimTimeout = null;\n    nodeClasses.add(activeClassName);\n    if (active) {\n      setTimeout(active, 0);\n    }\n    fixBrowserByTimeout(node);\n    // 30ms for firefox\n  }, 30);\n\n  return {\n    stop: function stop() {\n      if (node.rcEndListener) {\n        node.rcEndListener();\n      }\n    }\n  };\n};\n\ncssAnimation.style = function (node, style, callback) {\n  if (node.rcEndListener) {\n    node.rcEndListener();\n  }\n\n  node.rcEndListener = function (e) {\n    if (e && e.target !== node) {\n      return;\n    }\n\n    if (node.rcAnimTimeout) {\n      clearTimeout(node.rcAnimTimeout);\n      node.rcAnimTimeout = null;\n    }\n\n    clearBrowserBugTimeout(node);\n\n    _Event2[\"default\"].removeEndEventListener(node, node.rcEndListener);\n    node.rcEndListener = null;\n\n    // Usually this optional callback is used for informing an owner of\n    // a leave animation and telling it to remove the child.\n    if (callback) {\n      callback();\n    }\n  };\n\n  _Event2[\"default\"].addEndEventListener(node, node.rcEndListener);\n\n  node.rcAnimTimeout = setTimeout(function () {\n    for (var s in style) {\n      if (style.hasOwnProperty(s)) {\n        node.style[s] = style[s];\n      }\n    }\n    node.rcAnimTimeout = null;\n    fixBrowserByTimeout(node);\n  }, 0);\n};\n\ncssAnimation.setTransition = function (node, p, value) {\n  var property = p;\n  var v = value;\n  if (value === undefined) {\n    v = property;\n    property = '';\n  }\n  property = property || '';\n  capitalPrefixes.forEach(function (prefix) {\n    node.style[prefix + 'Transition' + property] = v;\n  });\n};\n\ncssAnimation.isCssAnimationSupported = isCssAnimationSupported;\n\nexports[\"default\"] = cssAnimation;\nmodule.exports = exports['default'];\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-animation/lib/index.js\n ** module id = 12\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/css-animation/lib/index.js?");

/***/ },
/* 13 */
/***/ function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar EVENT_NAME_MAP = {\n  transitionend: {\n    transition: 'transitionend',\n    WebkitTransition: 'webkitTransitionEnd',\n    MozTransition: 'mozTransitionEnd',\n    OTransition: 'oTransitionEnd',\n    msTransition: 'MSTransitionEnd'\n  },\n\n  animationend: {\n    animation: 'animationend',\n    WebkitAnimation: 'webkitAnimationEnd',\n    MozAnimation: 'mozAnimationEnd',\n    OAnimation: 'oAnimationEnd',\n    msAnimation: 'MSAnimationEnd'\n  }\n};\n\nvar endEvents = [];\n\nfunction detectEvents() {\n  var testEl = document.createElement('div');\n  var style = testEl.style;\n\n  if (!('AnimationEvent' in window)) {\n    delete EVENT_NAME_MAP.animationend.animation;\n  }\n\n  if (!('TransitionEvent' in window)) {\n    delete EVENT_NAME_MAP.transitionend.transition;\n  }\n\n  for (var baseEventName in EVENT_NAME_MAP) {\n    if (EVENT_NAME_MAP.hasOwnProperty(baseEventName)) {\n      var baseEvents = EVENT_NAME_MAP[baseEventName];\n      for (var styleName in baseEvents) {\n        if (styleName in style) {\n          endEvents.push(baseEvents[styleName]);\n          break;\n        }\n      }\n    }\n  }\n}\n\nif (typeof window !== 'undefined' && typeof document !== 'undefined') {\n  detectEvents();\n}\n\nfunction addEventListener(node, eventName, eventListener) {\n  node.addEventListener(eventName, eventListener, false);\n}\n\nfunction removeEventListener(node, eventName, eventListener) {\n  node.removeEventListener(eventName, eventListener, false);\n}\n\nvar TransitionEvents = {\n  addEndEventListener: function addEndEventListener(node, eventListener) {\n    if (endEvents.length === 0) {\n      window.setTimeout(eventListener, 0);\n      return;\n    }\n    endEvents.forEach(function (endEvent) {\n      addEventListener(node, endEvent, eventListener);\n    });\n  },\n\n\n  endEvents: endEvents,\n\n  removeEndEventListener: function removeEndEventListener(node, eventListener) {\n    if (endEvents.length === 0) {\n      return;\n    }\n    endEvents.forEach(function (endEvent) {\n      removeEventListener(node, endEvent, eventListener);\n    });\n  }\n};\n\nexports[\"default\"] = TransitionEvents;\nmodule.exports = exports['default'];\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-animation/lib/Event.js\n ** module id = 13\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/css-animation/lib/Event.js?");

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Module dependencies.\n */\n\ntry {\n  var index = __webpack_require__(15);\n} catch (err) {\n  var index = __webpack_require__(15);\n}\n\n/**\n * Whitespace regexp.\n */\n\nvar re = /\\s+/;\n\n/**\n * toString reference.\n */\n\nvar toString = Object.prototype.toString;\n\n/**\n * Wrap `el` in a `ClassList`.\n *\n * @param {Element} el\n * @return {ClassList}\n * @api public\n */\n\nmodule.exports = function(el){\n  return new ClassList(el);\n};\n\n/**\n * Initialize a new ClassList for `el`.\n *\n * @param {Element} el\n * @api private\n */\n\nfunction ClassList(el) {\n  if (!el || !el.nodeType) {\n    throw new Error('A DOM element reference is required');\n  }\n  this.el = el;\n  this.list = el.classList;\n}\n\n/**\n * Add class `name` if not already present.\n *\n * @param {String} name\n * @return {ClassList}\n * @api public\n */\n\nClassList.prototype.add = function(name){\n  // classList\n  if (this.list) {\n    this.list.add(name);\n    return this;\n  }\n\n  // fallback\n  var arr = this.array();\n  var i = index(arr, name);\n  if (!~i) arr.push(name);\n  this.el.className = arr.join(' ');\n  return this;\n};\n\n/**\n * Remove class `name` when present, or\n * pass a regular expression to remove\n * any which match.\n *\n * @param {String|RegExp} name\n * @return {ClassList}\n * @api public\n */\n\nClassList.prototype.remove = function(name){\n  if ('[object RegExp]' == toString.call(name)) {\n    return this.removeMatching(name);\n  }\n\n  // classList\n  if (this.list) {\n    this.list.remove(name);\n    return this;\n  }\n\n  // fallback\n  var arr = this.array();\n  var i = index(arr, name);\n  if (~i) arr.splice(i, 1);\n  this.el.className = arr.join(' ');\n  return this;\n};\n\n/**\n * Remove all classes matching `re`.\n *\n * @param {RegExp} re\n * @return {ClassList}\n * @api private\n */\n\nClassList.prototype.removeMatching = function(re){\n  var arr = this.array();\n  for (var i = 0; i < arr.length; i++) {\n    if (re.test(arr[i])) {\n      this.remove(arr[i]);\n    }\n  }\n  return this;\n};\n\n/**\n * Toggle class `name`, can force state via `force`.\n *\n * For browsers that support classList, but do not support `force` yet,\n * the mistake will be detected and corrected.\n *\n * @param {String} name\n * @param {Boolean} force\n * @return {ClassList}\n * @api public\n */\n\nClassList.prototype.toggle = function(name, force){\n  // classList\n  if (this.list) {\n    if (\"undefined\" !== typeof force) {\n      if (force !== this.list.toggle(name, force)) {\n        this.list.toggle(name); // toggle again to correct\n      }\n    } else {\n      this.list.toggle(name);\n    }\n    return this;\n  }\n\n  // fallback\n  if (\"undefined\" !== typeof force) {\n    if (!force) {\n      this.remove(name);\n    } else {\n      this.add(name);\n    }\n  } else {\n    if (this.has(name)) {\n      this.remove(name);\n    } else {\n      this.add(name);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return an array of classes.\n *\n * @return {Array}\n * @api public\n */\n\nClassList.prototype.array = function(){\n  var className = this.el.getAttribute('class') || '';\n  var str = className.replace(/^\\s+|\\s+$/g, '');\n  var arr = str.split(re);\n  if ('' === arr[0]) arr.shift();\n  return arr;\n};\n\n/**\n * Check if class `name` is present.\n *\n * @param {String} name\n * @return {ClassList}\n * @api public\n */\n\nClassList.prototype.has =\nClassList.prototype.contains = function(name){\n  return this.list\n    ? this.list.contains(name)\n    : !! ~index(this.array(), name);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/component-classes/index.js\n ** module id = 14\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/component-classes/index.js?");

/***/ },
/* 15 */
/***/ function(module, exports) {

	eval("module.exports = function(arr, obj){\n  if (arr.indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/component-indexof/index.js\n ** module id = 15\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/component-indexof/index.js?");

/***/ },
/* 16 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar util = {\n  isAppearSupported: function isAppearSupported(props) {\n    return props.transitionName && props.transitionAppear || props.animation.appear;\n  },\n  isEnterSupported: function isEnterSupported(props) {\n    return props.transitionName && props.transitionEnter || props.animation.enter;\n  },\n  isLeaveSupported: function isLeaveSupported(props) {\n    return props.transitionName && props.transitionLeave || props.animation.leave;\n  },\n\n  allowAppearCallback: function allowAppearCallback(props) {\n    return props.transitionAppear || props.animation.appear;\n  },\n  allowEnterCallback: function allowEnterCallback(props) {\n    return props.transitionEnter || props.animation.enter;\n  },\n  allowLeaveCallback: function allowLeaveCallback(props) {\n    return props.transitionLeave || props.animation.leave;\n  }\n};\nexports[\"default\"] = util;\nmodule.exports = exports[\"default\"];\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rc-animate/lib/util.js\n ** module id = 16\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/rc-animate/lib/util.js?");

/***/ },
/* 17 */
/***/ function(module, exports) {

	eval("'use strict';\n\nvar idCounter = 0;\n\nvar tileUtils = {\n  tid: function tid(prefix) {\n    return (prefix || '') + idCounter++;\n  },\n  updateTid: function updateTid(tid) {\n    var validId = tid.match(/^[rct](\\d+)$/);\n    if (validId) {\n      validId = parseInt(validId[1]);\n      if (validId >= idCounter) {\n        idCounter = validId + 1;\n      }\n    }\n  }\n};\n\n// Adds requestAnimationFrame to the utils\nvar lastTime = 0;\nvar vendors = ['webkit', 'moz'];\nif (window.requestAnimationFrame) {\n  tileUtils.requestAnimationFrame = window.requestAnimationFrame;\n  tileUtils.cancelAnimationFrame = window.cancelAnimationFrame;\n} else {\n  for (var x = 0; x < vendors.length && !tileUtils.requestAnimationFrame; ++x) {\n    tileUtils.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n    tileUtils.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n  }\n}\n\nif (!tileUtils.requestAnimationFrame) {\n  tileUtils.requestAnimationFrame = function (callback, element) {\n    var currTime = new Date().getTime();\n    var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n    var id = window.setTimeout(function () {\n      callback(currTime + timeToCall);\n    }, timeToCall);\n    lastTime = currTime + timeToCall;\n    return id;\n  };\n} else {\n  tileUtils.requestAnimationFrame = tileUtils.requestAnimationFrame.bind(window);\n}\n\nif (!tileUtils.cancelAnimationFrame) {\n  tileUtils.cancelAnimationFrame = function (id) {\n    clearTimeout(id);\n  };\n} else {\n  tileUtils.cancelAnimationFrame = tileUtils.cancelAnimationFrame.bind(window);\n}\n\nmodule.exports = tileUtils;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/utils/TileUtils.js\n ** module id = 17\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/utils/TileUtils.js?");

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar React = __webpack_require__(2),\n    Tile = __webpack_require__(5),\n    assign = __webpack_require__(7),\n    Animate = __webpack_require__(8),\n    utils = __webpack_require__(17);\n\nvar FloatingWrapper = React.createClass({\n  displayName: 'FloatingWrapper',\n\n  getInitialState: function getInitialState() {\n    var _this = this;\n\n    var dimensions = {},\n        i = 0;\n\n    Object.keys(this.props.tiles).forEach(function (tileId) {\n      dimensions[tileId] = _this.getInitialTileDimensions(i++);\n    });\n\n    return {\n      dimensions: dimensions,\n      moving: false,\n      currentTile: false\n    };\n  },\n\n  render: function render() {\n    var className = 'floatingWrapper';\n\n    return React.createElement(\n      Animate,\n      { ref: 'animate', component: 'div', className: className, transitionName: 'tilewrapper' },\n      this.renderTiles()\n    );\n  },\n  renderTiles: function renderTiles() {\n    var _this2 = this;\n\n    var tiles = this.props.tiles,\n        me = this,\n        floating = [],\n        isMovingHandled = !this.props.moving;\n\n    Object.keys(tiles).forEach(function (tileId) {\n      if (!isMovingHandled) {\n        isMovingHandled = tileId === _this2.props.movingTile.id;\n      }\n      floating.push(_this2.renderTile(tileId));\n    });\n\n    if (!isMovingHandled) {\n      floating.push(this.renderTile(this.props.movingTile.id));\n    }\n\n    return floating;\n  },\n\n  renderTile: function renderTile(tileId) {\n    var _this3 = this;\n\n    var tile = this.props.tiles[tileId];\n    return React.createElement(Tile, _extends({}, this.props, {\n      key: tileId,\n      layout: { id: tileId, route: tile, type: 'floating' },\n      dimensions: this.props.boxes[tileId],\n      resizing: this.state.resizing,\n      onMoveStart: this.props.onMoveStart,\n      onResizeStart: this.props.onResizeStart,\n      onClick: function onClick(tid) {\n        return _this3.setState({ currentTile: tid });\n      },\n      isCurrentTile: tileId === this.state.currentTile,\n      wrapper: { id: 'floating', type: 'floating' } }));\n  },\n\n  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {\n    var _this4 = this;\n\n    if (nextProps.tiles !== this.props.tiles) {\n      var i = Object.keys(this.state.dimensions).length,\n          dimensions = {},\n          update = {};\n\n      Object.keys(nextProps.tiles).forEach(function (tileId) {\n        dimensions[tileId] = _this4.state.dimensions[tileId];\n        if (!dimensions[tileId]) {\n          // new tile!\n          dimensions[tileId] = _this4.getInitialTileDimensions(i++);\n          update.currentTile = tileId;\n        }\n      });\n\n      update.dimensions = dimensions;\n      this.setState(update);\n    }\n  },\n  getInitialTileDimensions: function getInitialTileDimensions(i) {\n    return {\n      width: 400,\n      height: 300,\n      top: 100 + 50 * i,\n      left: 100 + 50 * i\n    };\n  }\n\n});\n\nmodule.exports = FloatingWrapper;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/FloatingWrapper.js\n ** module id = 18\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/components/FloatingWrapper.js?");

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar React = __webpack_require__(2);\nvar utils = __webpack_require__(17);\n\nvar TileManager;\n/**\r\n * A component to load new routes on the layout. By default it opens the route\r\n * in the current tile, but it's possible to specify the tileId of the tile to open\r\n * the route.\r\n * If the tile is given and it can be found on the layout, it creates a new tile.\r\n * It's possible to pass \"floating\" as the wrapper to make the tile floating.\r\n *\r\n */\nvar TileLink = React.createClass({\n  displayName: 'TileLink',\n\n  contextTypes: {\n    tileLayout: React.PropTypes.object,\n    wrapperId: React.PropTypes.string,\n    builder: React.PropTypes.object,\n    resolver: React.PropTypes.object\n  },\n\n  getInitialState: function getInitialState() {\n    this.tid = utils.tid('t');\n    return {};\n  },\n\n  render: function render() {\n    var _this = this;\n\n    // console.log( this.context.tileLayout );\n    return React.createElement(\n      'a',\n      { href: this.getUrl(), className: this.props.className, style: this.props.style, onClick: function onClick(e) {\n          return _this.navigate(e);\n        } },\n      this.props.children\n    );\n  },\n\n  getUrl: function getUrl() {\n    if (!this.props.to) {\n      return;\n    }\n\n    var routeParts = this.props.to.split('#'),\n        url;\n\n    if (this.props.single) {\n      console.log;\n      return this.props.to;\n    }\n\n    var builder = this.context.builder,\n        tileData = {\n      route: routeParts[0],\n      tile: this.props.tile || (this.props.wrapper ? this.tid : this.context.tileLayout.id),\n      wrapper: this.props.wrapper || this.context.wrapperId,\n      type: this.props.type,\n      position: this.props.position\n    };\n\n    url = builder.setTile(tileData);\n\n    if (routeParts.length > 1) {\n      url += '#' + routeParts[routeParts.length - 1];\n    }\n\n    return url;\n  },\n\n  navigate: function navigate(e) {\n    if (this.props.onClick) {\n      this.props.onClick(e);\n    }\n\n    e.preventDefault();\n    this.context.resolver.navigate(this.getUrl());\n    this.tid = utils.tid('t');\n  }\n});\n\nTileLink.setManager = function (tm) {\n  TileManager = tm;\n};\n\nmodule.exports = TileLink;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/TileLink.js\n ** module id = 19\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/components/TileLink.js?");

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar UrlParser = __webpack_require__(21),\n    assign = __webpack_require__(7),\n    utils = __webpack_require__(17);\n\nvar tileCounter = 0;\n\nvar TileQueryBuilder = function TileQueryBuilder(route) {\n  this.setRoute(route);\n};\n\nassign(TileQueryBuilder.prototype, {\n  setRoute: function setRoute(route) {\n    this.layout = UrlParser.parse(route);\n  },\n\n  setLayout: function setLayout(layout) {\n    this.layout = layout;\n  },\n\n  swapType: function swapType(update) {\n    if (this.layout.type === 'free') {\n      return this.layout.query;\n    }\n\n    var type = this.layout.type === 'row' ? 'column' : 'row',\n        nextLayout = toLayout(this.layout, type);\n\n    return this.layoutToPath(layout, update);\n  },\n\n  remove: function remove(id, update, returnLayout) {\n    if (!id) {\n      this.throwError(\"`remove` needs a tile id.\");\n    }\n\n    var nextLayout = cloneLayout(this.layout),\n        i = nextLayout.children.length,\n        tileIndex,\n        wrapper;\n\n    if (nextLayout.floating[id]) {\n      nextLayout.floating = assign({}, nextLayout.floating);\n      delete nextLayout.floating[id];\n    } else {\n      while (i-- > 0) {\n        tileIndex = findIndex(nextLayout.children[i], id);\n        if (tileIndex !== -1) {\n          if (nextLayout.children[i].children.length === 1) {\n\n            // If it was the only child, remove the wrapper\n            nextLayout.children.splice(i, 1);\n          } else {\n            wrapper = cloneLayout(nextLayout.children[i]);\n            wrapper.children.splice(tileIndex, 1);\n            nextLayout.children[i] = wrapper;\n          }\n          if (nextLayout.children.length === 1) {\n            nextLayout.children[0] = cloneLayout(nextLayout.children[0]);\n            if (nextLayout.children[0].children.length === 1) {\n              nextLayout.type = 'free';\n              nextLayout.children[0].type = 'freeChild';\n            }\n          }\n          return this.layoutToPath(nextLayout, update, returnLayout);\n        }\n      }\n    }\n\n    return this.layoutToPath(nextLayout, update, returnLayout);\n  },\n\n  resetWrapper: function resetWrapper(id, tile, update, returnLayout) {\n    if (!id || !tile || !tile.route) {\n      this.throwError(\"`resetWrapper` needs a wrapper id and a new tile data with a route.\");\n    }\n\n    var found = find(this.layout, id);\n\n    if (!found) {\n      return console.log(\"Wrapper \" + id + \" not found to reset.\");\n    }\n\n    found[0].children = [createTile(tile)];\n\n    return this.layoutToPath(found[1], update, returnLayout);\n  },\n\n  handleErrors: function handleErrors(type, payload) {\n    if (!payload) {\n      this.throwError('`' + type + '` called without parameters.');\n    }\n    if (type === 'setTile') {\n      if (!payload.route) {\n        this.throwError('`setTile` needs a route.');\n      } else if (!payload.wrapper) {\n        this.throwError('`setTile` needs a target.');\n      }\n    }\n  },\n\n  throwError: function throwError(reason) {\n    throw new Error('QueryBuilder ERROR: ' + reason);\n  },\n  layoutToPath: function layoutToPath(layout, update, returnLayout) {\n\n    var q, floating;\n    if (layout.type === 'free') {\n      q = layout.children[0].children[0].route + '?tw=' + layout.id + ':' + layout.children[0].id + ':' + layout.children[0].children[0].id;\n    } else {\n      q = layout.path + '?t=' + UrlParser.stringify(layout);\n    }\n\n    floating = UrlParser.stringifyFloating(layout);\n    if (floating) {\n      q += '&ft=' + floating;\n    }\n\n    // layout.query = q;\n    if (update) {\n      this.layout = layout;\n    }\n\n    if (returnLayout) {\n      return layout;\n    } else {\n      return pathFormat + q;\n    }\n  },\n\n  setTile: function setTile(ops, returnLayout) {\n    this.handleErrors('setTile', ops);\n    var nextLayout = cloneLayout(this.layout),\n        children = nextLayout.children;\n\n    // If the tile id exists open the route there, ignore anything else\n    // Look for it in the floating tiles\n    if (nextLayout.floating[ops.tile]) {\n      nextLayout.floating = assign({}, nextLayout.floating);\n      nextLayout.floating[ops.tile] = ops.route;\n      return this.layoutToPath(nextLayout, ops.update, returnLayout);\n    }\n    // And in the not floating ones\n    if (ops.tile) {\n      var i = children.length,\n          j;\n\n      while (i-- > 0) {\n        j = children[i].children.length;\n        while (j-- > 0) {\n          if (children[i].children[j].id === ops.tile) {\n            children[i] = cloneLayout(children[i]);\n            children[i].children[j] = cloneLayout(children[i].children[j]);\n            children[i].children[j].route = ops.route;\n\n            // Return here\n            return this.layoutToPath(nextLayout, ops.update, returnLayout);\n          }\n        }\n      }\n    }\n\n    // Check if the tile is floating\n    if (ops.wrapper === 'floating') {\n      nextLayout.floating = assign({}, nextLayout.floating);\n      nextLayout.floating[ops.tile] = ops.route;\n      return this.layoutToPath(nextLayout, ops.update, returnLayout);\n    }\n\n    var position = ops.wrapperPosition !== undefined ? ops.wrapperPosition : nextLayout.children.length,\n        wrapper = { children: [] };\n\n    // If the layout is free we need to create a new wrapper for the tile\n    if (nextLayout.type === 'free') {\n      // the default layout is column one\n      nextLayout.type = ops.type === 'row' ? 'column' : 'row';\n      wrapper.type = nextLayout.type === 'row' ? 'column' : 'row';\n      children[0] = cloneLayout(children[0]);\n      children[0].type = wrapper.type;\n      wrapper.id = ops.wrapper && ops.wrapper !== children[0].id ? ops.wrapper : utils.tid(wrapper.type[0]);\n\n      // Add the wrapper to the layout\n      children.splice(position, 0, wrapper);\n    } else {\n      // If the wrapper is already there use it\n      var wrapperIndex = findIndex(nextLayout, ops.wrapper);\n      if (wrapperIndex !== -1) {\n        wrapper = cloneLayout(children[wrapperIndex]);\n\n        // Add the wrapper to the layout\n        children[wrapperIndex] = wrapper;\n      } else {\n        wrapper.type = children[0].type;\n        wrapper.id = ops.wrapper || utils.tid(wrapper.type[0]);\n\n        // Add the wrapper to the layout\n        children.splice(position, 0, wrapper);\n      }\n    }\n\n    // Add the tile to the wrapper\n    wrapper.children.splice(ops.position || wrapper.children.length, 0, createTile(ops));\n\n    return this.layoutToPath(nextLayout, ops.update, returnLayout);\n  },\n\n  getWrapperInfo: function getWrapperInfo(id) {\n    var index = findIndex(this.layout, id);\n    return index !== -1 && cloneLayout(this.layout.children[index]);\n  },\n\n  setFloating: function setFloating(id, update, returnLayout) {\n\n    // Needs to get the layout from remove\n    var i = this.layout.children.length,\n        found = false,\n        tileIndex;\n\n    if (this.layout.floating[id]) {\n      return this.layoutToPath(cloneLayout(this.layout), update, returnLayout);\n    }\n\n    while (i-- > 0 && !found) {\n      tileIndex = findIndex(nextLayout.children[i], id);\n      if (tileIndex !== -1) {\n        found = nextLayout.children[i].children[tileIndex];\n      }\n    }\n\n    if (!found) {\n      this.throwError(\"`setFloating` tile \" + id + \" not found.\");\n    }\n\n    var nextLayout = this.remove(id, false, true);\n    nextLayout.floating[id] = found.route;\n    return this.layoutToPath(nextLayout, update, returnLayout);\n  }\n});\n\nvar pathFormat = '';\nTileQueryBuilder.setPathFormat = function (format) {\n  pathFormat = format;\n};\n\nmodule.exports = TileQueryBuilder;\n\n/** HELPERS **/\nvar toLayout = function toLayout(currentLayout, toType, ops) {\n  var currentType = currentLayout.type,\n      otherType = currentType === 'row' ? 'column' : 'row',\n      q,\n      layout;\n\n  if (currentType === toType) {\n    // Same type, return it unmodified\n    return currentLayout;\n  } else if (otherType === toType) {\n    // Swap types\n    layout = assign({}, currentLayout, { type: toType, children: [] });\n    currentLayout.children.forEach(function (child) {\n      layout.children.push(assign({}, child, { type: otherType }));\n    });\n  } else {\n    // Free type wrapper, switch it to the desired type and add a otherType child with the tile\n    layout = assign({}, currentLayout, { type: toType, id: ops.columnId || utils.tid(toType[0]), children: [{ type: otherType, id: ops.rowId || utils.tid(otherType[0]), children: currentLayout.children }] });\n  }\n\n  return layout;\n};\n\nvar cloneLayout = function cloneLayout(l) {\n  var clone = assign({}, l);\n  clone.children = l.children && l.children.slice();\n  return clone;\n};\n\nvar findIndex = function findIndex(layout, id) {\n  if (!id) {\n    return -1;\n  }\n\n  var i = layout.children.length;\n  while (i-- > 0) {\n    if (layout.children[i].id === id) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\nvar createTile = function createTile(ops) {\n  return {\n    id: ops.tile || utils.tid('t'),\n    route: ops.route,\n    type: 'tile'\n  };\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/utils/QueryBuilder.js\n ** module id = 20\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/utils/QueryBuilder.js?");

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar qs = __webpack_require__(22),\n    utils = __webpack_require__(17);\n\nvar UrlParser = {\n  stringify: function stringify(layout) {\n    if (layout.type === 'tile') {\n      return layout.id + ':' + encodeURIComponent(encodeURIComponent(layout.route));\n    }\n\n    var me = this,\n        children = layout.children.map(function (child) {\n      return me.stringify(child);\n    });\n\n    var str = layout.type === 'row' ? 'r' : 'c',\n        query = str + ':' + layout.id + '{' + children.join(',') + '}',\n        floating = this.stringifyFloating(layout);\n\n    if (floating) {\n      query += '&' + floating;\n    }\n\n    return query;\n  },\n\n  parse: function parse(route) {\n    var parts = route.split('?'),\n        path = parts[0],\n        query = parts[1] && qs.parse(parts[1]) || {},\n        layout;\n\n    if (query.t) {\n      layout = this.parseQuery(query.t);\n    } else {\n      // wrapper ids\n      var layoutId = 'm',\n          // after main\n      wrapperId = 'mc',\n          // after main child\n      tileId = 'mct',\n          ids;\n      if (query.tw) {\n        ids = query.tw.split(':');\n        if (ids[2].indexOf('#') !== -1) {\n          // There is a fragment in the url\n          ids[2] = ids[2].split('#')[0];\n        }\n        if (ids.length == 3) {\n          layoutId = ids[0];\n          wrapperId = ids[1];\n          tileId = ids[2];\n        }\n      }\n      layout = {\n        type: 'free',\n        id: layoutId,\n        children: [{\n          type: 'freeChild',\n          id: wrapperId,\n          children: [{\n            type: 'tile',\n            route: path,\n            id: tileId\n          }]\n        }]\n      };\n    }\n\n    // floating tiles are in the format {id:route}\n    layout.floating = this.parseFloating(query.ft);\n\n    layout.route = path;\n    layout.path = parts[0];\n    layout.query = query.t;\n\n    return layout;\n  },\n\n  stringifyFloating: function stringifyFloating(layout) {\n    if (!layout.floating) {\n      return false;\n    }\n    var floating = [];\n    Object.keys(layout.floating).forEach(function (tid) {\n      floating.push(tid + ':' + encodeURIComponent(encodeURIComponent(layout.floating[tid])));\n    });\n    return floating.join(',');\n  },\n\n  parseQuery: function parseQuery(tileQuery) {\n    var tokens = this.tokenize(tileQuery),\n        layout = this.parseWrapper(tokens);\n\n    return layout;\n  },\n\n  tokenize: function tokenize(tileQuery) {\n    var tokens = [],\n        buffer = '';\n\n    for (var i = 0; i < tileQuery.length; i++) {\n      var current = tileQuery[i];\n\n      if (current == '{') {\n        if (buffer.length) {\n          tokens.push({ type: 'wrapperId', value: buffer });\n          buffer = '';\n        }\n        tokens.push({ type: 'wrapperOpen', value: current });\n      } else if (current == '}') {\n        if (buffer.length) {\n          tokens.push({ type: 'wrapperId', value: buffer });\n          buffer = '';\n        }\n        tokens.push({ type: 'wrapperClose', value: current });\n      } else if (current == ',') {\n        if (buffer.length) {\n          tokens.push({ type: 'wrapperId', value: buffer });\n          buffer = '';\n        }\n        tokens.push({ type: 'separator', value: current });\n      } else {\n        buffer += current;\n      }\n    }\n\n    if (buffer.length) {\n      throw this.getError('Unexpected ' + buffer);\n    }\n\n    return tokens;\n  },\n\n  parseWrapper: function parseWrapper(tokens) {\n    var token = tokens.shift();\n\n    if (token.type !== 'wrapperId') {\n      throw this.getError('Unexpected ' + token.value);\n    }\n\n    var layout = this.parseId(token);\n    if (layout.type === 'tile') {\n      return layout;\n    }\n\n    token = tokens.shift();\n    if (token.type !== 'wrapperOpen') {\n      throw this.getError('Unexpected ' + token.value + ' after a column or row declaration.');\n    }\n    layout.children = this.parseChildren(tokens);\n\n    return layout;\n  },\n\n  parseId: function parseId(token) {\n    var parts = token.value.split(':');\n\n    if (parts.length !== 2) {\n      throw this.getError('Id ' + token.value + ' not valid.');\n    }\n\n    var layout = {\n      id: parts[1]\n    };\n\n    if (parts[0] === 'c') {\n      layout.type = 'column';\n    } else if (parts[0] === 'r') {\n      layout.type = 'row';\n    } else {\n      layout = {\n        type: 'tile',\n        id: parts[0],\n        route: decodeURIComponent(parts[1])\n      };\n    }\n\n    utils.updateTid(layout.id);\n\n    return layout;\n  },\n  parseChildren: function parseChildren(tokens) {\n    var children = [],\n        token;\n    while (tokens.length) {\n      if (tokens[0].type !== 'wrapperId') {\n        throw this.getError('Unexpected ' + tokes[0].value + ' after a column or row declaration.');\n      }\n      children.push(this.parseWrapper(tokens));\n      token = tokens.shift();\n      if (token.type === 'wrapperClose') {\n        return children;\n      } else if (token.type !== 'separator') {\n        throw this.getError('Unexpected ' + token.value);\n      }\n    }\n\n    // If we reach here, we failed to close a parenthesis.\n    throw this.getError('Unexpected End');\n  },\n\n\n  getError: function getError(msg) {\n    return new Error(\"Tile query parse error: \" + msg);\n  },\n\n  parseFloating: function parseFloating(param) {\n    if (!param) return {};\n    var tiles = param.split(','),\n        floating = {},\n        parts;\n\n    for (var i = 0; i < tiles.length; i++) {\n      parts = tiles[i].split(':');\n      if (parts.length == 2) {\n        floating[parts[0]] = decodeURIComponent(parts[1]);\n      }\n    }\n\n    return floating;\n  }\n};\n\nwindow.parser = UrlParser;\nmodule.exports = UrlParser;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/utils/UrlParser.js\n ** module id = 21\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/utils/UrlParser.js?");

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar Stringify = __webpack_require__(23);\nvar Parse = __webpack_require__(25);\n\nmodule.exports = {\n    stringify: Stringify,\n    parse: Parse\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/qs/lib/index.js\n ** module id = 22\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/qs/lib/index.js?");

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar Utils = __webpack_require__(24);\n\nvar arrayPrefixGenerators = {\n    brackets: function brackets(prefix) {\n        return prefix + '[]';\n    },\n    indices: function indices(prefix, key) {\n        return prefix + '[' + key + ']';\n    },\n    repeat: function repeat(prefix) {\n        return prefix;\n    }\n};\n\nvar defaults = {\n    delimiter: '&',\n    strictNullHandling: false,\n    skipNulls: false,\n    encode: true,\n    encoder: Utils.encode\n};\n\nvar stringify = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots) {\n    var obj = object;\n    if (typeof filter === 'function') {\n        obj = filter(prefix, obj);\n    } else if (obj instanceof Date) {\n        obj = obj.toISOString();\n    } else if (obj === null) {\n        if (strictNullHandling) {\n            return encoder ? encoder(prefix) : prefix;\n        }\n\n        obj = '';\n    }\n\n    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || Utils.isBuffer(obj)) {\n        if (encoder) {\n            return [encoder(prefix) + '=' + encoder(obj)];\n        }\n        return [prefix + '=' + String(obj)];\n    }\n\n    var values = [];\n\n    if (typeof obj === 'undefined') {\n        return values;\n    }\n\n    var objKeys;\n    if (Array.isArray(filter)) {\n        objKeys = filter;\n    } else {\n        var keys = Object.keys(obj);\n        objKeys = sort ? keys.sort(sort) : keys;\n    }\n\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n\n        if (skipNulls && obj[key] === null) {\n            continue;\n        }\n\n        if (Array.isArray(obj)) {\n            values = values.concat(stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));\n        } else {\n            values = values.concat(stringify(obj[key], prefix + (allowDots ? '.' + key : '[' + key + ']'), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));\n        }\n    }\n\n    return values;\n};\n\nmodule.exports = function (object, opts) {\n    var obj = object;\n    var options = opts || {};\n    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;\n    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;\n    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;\n    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;\n    var encoder = encode ? (typeof options.encoder === 'function' ? options.encoder : defaults.encoder) : null;\n    var sort = typeof options.sort === 'function' ? options.sort : null;\n    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;\n    var objKeys;\n    var filter;\n\n    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {\n        throw new TypeError('Encoder has to be a function.');\n    }\n\n    if (typeof options.filter === 'function') {\n        filter = options.filter;\n        obj = filter('', obj);\n    } else if (Array.isArray(options.filter)) {\n        objKeys = filter = options.filter;\n    }\n\n    var keys = [];\n\n    if (typeof obj !== 'object' || obj === null) {\n        return '';\n    }\n\n    var arrayFormat;\n    if (options.arrayFormat in arrayPrefixGenerators) {\n        arrayFormat = options.arrayFormat;\n    } else if ('indices' in options) {\n        arrayFormat = options.indices ? 'indices' : 'repeat';\n    } else {\n        arrayFormat = 'indices';\n    }\n\n    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];\n\n    if (!objKeys) {\n        objKeys = Object.keys(obj);\n    }\n\n    if (sort) {\n        objKeys.sort(sort);\n    }\n\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n\n        if (skipNulls && obj[key] === null) {\n            continue;\n        }\n\n        keys = keys.concat(stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));\n    }\n\n    return keys.join(delimiter);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/qs/lib/stringify.js\n ** module id = 23\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/qs/lib/stringify.js?");

/***/ },
/* 24 */
/***/ function(module, exports) {

	eval("'use strict';\n\nvar hexTable = (function () {\n    var array = new Array(256);\n    for (var i = 0; i < 256; ++i) {\n        array[i] = '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase();\n    }\n\n    return array;\n}());\n\nexports.arrayToObject = function (source, options) {\n    var obj = options.plainObjects ? Object.create(null) : {};\n    for (var i = 0; i < source.length; ++i) {\n        if (typeof source[i] !== 'undefined') {\n            obj[i] = source[i];\n        }\n    }\n\n    return obj;\n};\n\nexports.merge = function (target, source, options) {\n    if (!source) {\n        return target;\n    }\n\n    if (typeof source !== 'object') {\n        if (Array.isArray(target)) {\n            target.push(source);\n        } else if (typeof target === 'object') {\n            target[source] = true;\n        } else {\n            return [target, source];\n        }\n\n        return target;\n    }\n\n    if (typeof target !== 'object') {\n        return [target].concat(source);\n    }\n\n    var mergeTarget = target;\n    if (Array.isArray(target) && !Array.isArray(source)) {\n        mergeTarget = exports.arrayToObject(target, options);\n    }\n\n    return Object.keys(source).reduce(function (acc, key) {\n        var value = source[key];\n\n        if (Object.prototype.hasOwnProperty.call(acc, key)) {\n            acc[key] = exports.merge(acc[key], value, options);\n        } else {\n            acc[key] = value;\n        }\n        return acc;\n    }, mergeTarget);\n};\n\nexports.decode = function (str) {\n    try {\n        return decodeURIComponent(str.replace(/\\+/g, ' '));\n    } catch (e) {\n        return str;\n    }\n};\n\nexports.encode = function (str) {\n    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\n    // It has been adapted here for stricter adherence to RFC 3986\n    if (str.length === 0) {\n        return str;\n    }\n\n    var string = typeof str === 'string' ? str : String(str);\n\n    var out = '';\n    for (var i = 0; i < string.length; ++i) {\n        var c = string.charCodeAt(i);\n\n        if (\n            c === 0x2D || // -\n            c === 0x2E || // .\n            c === 0x5F || // _\n            c === 0x7E || // ~\n            (c >= 0x30 && c <= 0x39) || // 0-9\n            (c >= 0x41 && c <= 0x5A) || // a-z\n            (c >= 0x61 && c <= 0x7A) // A-Z\n        ) {\n            out += string.charAt(i);\n            continue;\n        }\n\n        if (c < 0x80) {\n            out = out + hexTable[c];\n            continue;\n        }\n\n        if (c < 0x800) {\n            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        if (c < 0xD800 || c >= 0xE000) {\n            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        i += 1;\n        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));\n        out += hexTable[0xF0 | (c >> 18)] + hexTable[0x80 | ((c >> 12) & 0x3F)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)];\n    }\n\n    return out;\n};\n\nexports.compact = function (obj, references) {\n    if (typeof obj !== 'object' || obj === null) {\n        return obj;\n    }\n\n    var refs = references || [];\n    var lookup = refs.indexOf(obj);\n    if (lookup !== -1) {\n        return refs[lookup];\n    }\n\n    refs.push(obj);\n\n    if (Array.isArray(obj)) {\n        var compacted = [];\n\n        for (var i = 0; i < obj.length; ++i) {\n            if (obj[i] && typeof obj[i] === 'object') {\n                compacted.push(exports.compact(obj[i], refs));\n            } else if (typeof obj[i] !== 'undefined') {\n                compacted.push(obj[i]);\n            }\n        }\n\n        return compacted;\n    }\n\n    var keys = Object.keys(obj);\n    for (var j = 0; j < keys.length; ++j) {\n        var key = keys[j];\n        obj[key] = exports.compact(obj[key], refs);\n    }\n\n    return obj;\n};\n\nexports.isRegExp = function (obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\nexports.isBuffer = function (obj) {\n    if (obj === null || typeof obj === 'undefined') {\n        return false;\n    }\n\n    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/qs/lib/utils.js\n ** module id = 24\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/qs/lib/utils.js?");

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar Utils = __webpack_require__(24);\n\nvar defaults = {\n    delimiter: '&',\n    depth: 5,\n    arrayLimit: 20,\n    parameterLimit: 1000,\n    strictNullHandling: false,\n    plainObjects: false,\n    allowPrototypes: false,\n    allowDots: false,\n    decoder: Utils.decode\n};\n\nvar parseValues = function parseValues(str, options) {\n    var obj = {};\n    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);\n\n    for (var i = 0; i < parts.length; ++i) {\n        var part = parts[i];\n        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;\n\n        if (pos === -1) {\n            obj[options.decoder(part)] = '';\n\n            if (options.strictNullHandling) {\n                obj[options.decoder(part)] = null;\n            }\n        } else {\n            var key = options.decoder(part.slice(0, pos));\n            var val = options.decoder(part.slice(pos + 1));\n\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                obj[key] = [].concat(obj[key]).concat(val);\n            } else {\n                obj[key] = val;\n            }\n        }\n    }\n\n    return obj;\n};\n\nvar parseObject = function parseObject(chain, val, options) {\n    if (!chain.length) {\n        return val;\n    }\n\n    var root = chain.shift();\n\n    var obj;\n    if (root === '[]') {\n        obj = [];\n        obj = obj.concat(parseObject(chain, val, options));\n    } else {\n        obj = options.plainObjects ? Object.create(null) : {};\n        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;\n        var index = parseInt(cleanRoot, 10);\n        if (\n            !isNaN(index) &&\n            root !== cleanRoot &&\n            String(index) === cleanRoot &&\n            index >= 0 &&\n            (options.parseArrays && index <= options.arrayLimit)\n        ) {\n            obj = [];\n            obj[index] = parseObject(chain, val, options);\n        } else {\n            obj[cleanRoot] = parseObject(chain, val, options);\n        }\n    }\n\n    return obj;\n};\n\nvar parseKeys = function parseKeys(givenKey, val, options) {\n    if (!givenKey) {\n        return;\n    }\n\n    // Transform dot notation to bracket notation\n    var key = options.allowDots ? givenKey.replace(/\\.([^\\.\\[]+)/g, '[$1]') : givenKey;\n\n    // The regex chunks\n\n    var parent = /^([^\\[\\]]*)/;\n    var child = /(\\[[^\\[\\]]*\\])/g;\n\n    // Get the parent\n\n    var segment = parent.exec(key);\n\n    // Stash the parent if it exists\n\n    var keys = [];\n    if (segment[1]) {\n        // If we aren't using plain objects, optionally prefix keys\n        // that would overwrite object prototype properties\n        if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1])) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n\n        keys.push(segment[1]);\n    }\n\n    // Loop through children appending to the array until we hit depth\n\n    var i = 0;\n    while ((segment = child.exec(key)) !== null && i < options.depth) {\n        i += 1;\n        if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1].replace(/\\[|\\]/g, ''))) {\n            if (!options.allowPrototypes) {\n                continue;\n            }\n        }\n        keys.push(segment[1]);\n    }\n\n    // If there's a remainder, just add whatever is left\n\n    if (segment) {\n        keys.push('[' + key.slice(segment.index) + ']');\n    }\n\n    return parseObject(keys, val, options);\n};\n\nmodule.exports = function (str, opts) {\n    var options = opts || {};\n\n    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {\n        throw new TypeError('Decoder has to be a function.');\n    }\n\n    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;\n    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;\n    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;\n    options.parseArrays = options.parseArrays !== false;\n    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;\n    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;\n    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;\n    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;\n    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;\n    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;\n\n    if (str === '' || str === null || typeof str === 'undefined') {\n        return options.plainObjects ? Object.create(null) : {};\n    }\n\n    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;\n    var obj = options.plainObjects ? Object.create(null) : {};\n\n    // Iterate over the keys and setup the new object\n\n    var keys = Object.keys(tempObj);\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var newObj = parseKeys(key, tempObj[key], options);\n        obj = Utils.merge(obj, newObj, options);\n    }\n\n    return Utils.compact(obj);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/qs/lib/parse.js\n ** module id = 25\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/qs/lib/parse.js?");

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(27);\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(29)(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../node_modules/css-loader/index.js!./../node_modules/postcss-loader/index.js!./../node_modules/sass-loader/index.js!./tiles.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../node_modules/css-loader/index.js!./../node_modules/postcss-loader/index.js!./../node_modules/sass-loader/index.js!./tiles.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/tiles.scss\n ** module id = 26\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/tiles.scss?");

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	eval("exports = module.exports = __webpack_require__(28)();\n// imports\n\n\n// module\nexports.push([module.id, \".tilecontainer {\\n  position: relative;\\n  width: 100%;\\n  height: 100%;\\n  overflow: hidden; }\\n\\n.tilecolumn {\\n  height: 100%;\\n  position: relative;\\n  overflow: hidden;\\n  float: left;\\n  -webkit-transition: width 0.3s;\\n  transition: width 0.3s; }\\n  .tilecolumn > .tilewrapper, .tilecolumn > .singletile {\\n    -webkit-transition: height 0.3s;\\n    transition: height 0.3s;\\n    width: 100% !important;\\n    border-top: 3px solid #ccc; }\\n    .tilecolumn > .tilewrapper:first-child, .tilecolumn > .singletile:first-child {\\n      border-top: 0; }\\n  .tilecolumn.tilewrapper-leave {\\n    width: 0 !important; }\\n\\n.rowsingletile.tilewrapper-leave {\\n  width: 0 !important; }\\n\\n.columnsingletile.tilewrapper-leave {\\n  height: 0 !important; }\\n\\n.tilerow {\\n  position: relative;\\n  overflow: hidden;\\n  -webkit-transition: height 0.3s;\\n  transition: height 0.3s; }\\n  .tilerow > .tilewrapper, .tilerow > .singletile {\\n    -webkit-transition: width 0.3s;\\n    transition: width 0.3s;\\n    border-left: 3px solid #ccc; }\\n    .tilerow > .tilewrapper:first-child, .tilerow > .singletile:first-child {\\n      border-left: 0; }\\n  .tilerow > .singletile {\\n    height: 100% !important;\\n    float: left; }\\n  .tilerow.tilewrapper-leave {\\n    height: 0 !important; }\\n\\n.tilefreeChild {\\n  -webkit-transition: width 0.3s, height 0.3s;\\n  transition: width 0.3s, height 0.3s;\\n  float: left; }\\n  .tilefreeChild > .singletile {\\n    -webkit-transition: width 0.3s, height 0.3s;\\n    transition: width 0.3s, height 0.3s;\\n    float: left; }\\n\\n.singletile {\\n  overflow: hidden;\\n  position: relative; }\\n\\n.tilecontent {\\n  overflow: auto;\\n  width: 100%;\\n  height: 100%; }\\n\\n.tileresizing {\\n  -moz-user-select: none;\\n  /* Firefox */\\n  -ms-user-select: none;\\n  /* Internet Explorer */\\n  -khtml-user-select: none;\\n  /* KHTML browsers (e.g. Konqueror) */\\n  -webkit-user-select: none;\\n  /* Chrome, Safari, and Opera */\\n  -webkit-touch-callout: none;\\n  /* Disable Android and iOS callouts*/ }\\n  .tileresizing .tilerow, .tileresizing .tilecolumn, .tileresizing .singletile, .tileresizing .separator {\\n    -webkit-transition: none;\\n    transition: none; }\\n\\n.tilemoving {\\n  -moz-user-select: none;\\n  /* Firefox */\\n  -ms-user-select: none;\\n  /* Internet Explorer */\\n  -khtml-user-select: none;\\n  /* KHTML browsers (e.g. Konqueror) */\\n  -webkit-user-select: none;\\n  /* Chrome, Safari, and Opera */\\n  -webkit-touch-callout: none;\\n  /* Disable Android and iOS callouts*/ }\\n\\n.tilecolumn.tileentered > .tileentering {\\n  height: 0 !important; }\\n\\n.tilerow.tileentered > .tileentering {\\n  width: 0 !important; }\\n\\n.separator {\\n  position: absolute; }\\n\\n.separator-row {\\n  height: 100%;\\n  width: 3px;\\n  top: 0;\\n  cursor: e-resize; }\\n\\n.separator-column {\\n  width: 100%;\\n  height: 3px;\\n  left: 0;\\n  cursor: n-resize; }\\n\\n.tileiframe .tilecontent {\\n  overflow: hidden; }\\n\\n.tileiframe iframe {\\n  width: 100%;\\n  height: 100%;\\n  border: 0; }\\n\\n.tileiframeOverlay {\\n  width: 100%;\\n  height: 100%;\\n  position: absolute;\\n  z-index: -1; }\\n\\n.tileresizing .tileiframeOverlay, .tilemoving .tileiframeOverlay {\\n  z-index: 1; }\\n\\n.tilecontrols {\\n  position: absolute;\\n  top: 0;\\n  right: 15px;\\n  text-align: right;\\n  width: 100%;\\n  padding: 5px 0;\\n  opacity: .3;\\n  -webkit-transition: .3s opacity;\\n  transition: .3s opacity;\\n  font-size: 1.3em;\\n  background: rgba(255, 255, 255, 0.7); }\\n  .tilecontrols:hover {\\n    opacity: 1; }\\n  .tilecontrols a {\\n    cursor: pointer;\\n    color: #666;\\n    text-decoration: none;\\n    display: inline-block;\\n    min-width: 30px;\\n    text-align: center; }\\n    .tilecontrols a:hover {\\n      color: #333;\\n      text-decoration: none; }\\n\\n.tilefree .tilecontrols {\\n  display: none; }\\n\\n.floatingWrapper {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  width: 0;\\n  height: 0;\\n  z-index: 1; }\\n\\n.floatingsingletile {\\n  position: absolute;\\n  background: #fff;\\n  border: 1px solid #eee;\\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\\n  -webkit-transition: opacity 0.3s, -webkit-transform 0.3s;\\n  transition: opacity 0.3s, -webkit-transform 0.3s;\\n  transition: opacity 0.3s, transform 0.3s;\\n  transition: opacity 0.3s, transform 0.3s, -webkit-transform 0.3s; }\\n  .floatingsingletile.tilewrapper-leave {\\n    opacity: 0;\\n    -webkit-transform: scale(0.5) translate(0, -100px);\\n            transform: scale(0.5) translate(0, -100px); }\\n\\n.tilecurrent {\\n  z-index: 2; }\\n\\n.tileResizers > div {\\n  position: absolute;\\n  z-index: 5; }\\n\\n.resizer-n {\\n  height: 5px;\\n  width: 100%;\\n  left: 0;\\n  top: -2px;\\n  cursor: n-resize; }\\n\\n.resizer-ne {\\n  width: 5px;\\n  height: 5px;\\n  z-index: 6;\\n  top: -2px;\\n  right: -2px;\\n  cursor: ne-resize; }\\n\\n.resizer-e {\\n  width: 5px;\\n  height: 100%;\\n  top: -2px;\\n  right: -2px;\\n  cursor: e-resize; }\\n\\n.resizer-se {\\n  width: 5px;\\n  height: 5px;\\n  z-index: 6;\\n  bottom: -2px;\\n  right: -2px;\\n  cursor: se-resize; }\\n\\n.resizer-s {\\n  height: 5px;\\n  width: 100%;\\n  left: -2px;\\n  bottom: -2px;\\n  cursor: n-resize; }\\n\\n.resizer-sw {\\n  width: 5px;\\n  height: 5px;\\n  z-index: 6;\\n  bottom: -2px;\\n  left: -2px;\\n  cursor: ne-resize; }\\n\\n.resizer-w {\\n  width: 5px;\\n  height: 100%;\\n  top: -2px;\\n  left: -2px;\\n  cursor: e-resize; }\\n\\n.resizer-nw {\\n  width: 5px;\\n  height: 5px;\\n  z-index: 6;\\n  top: -2px;\\n  left: -2px;\\n  cursor: se-resize; }\\n\\n.tileph {\\n  background: #ccc;\\n  float: left;\\n  position: absolute;\\n  -webkit-transition: width 0.3s, height 0.3s, opacity 0.3s;\\n  transition: width 0.3s, height 0.3s, opacity 0.3s; }\\n\\n.rowph {\\n  height: 100%;\\n  width: 20%;\\n  top: 0;\\n  right: 0; }\\n  .rowph.tilewrapper-enter {\\n    width: 0%;\\n    opacity: 0; }\\n    .rowph.tilewrapper-enter.tilewrapper-enter-active {\\n      width: 20%;\\n      opacity: 1; }\\n  .rowph.tilewrapper-leave {\\n    width: 0%;\\n    opacity: 0; }\\n\\n.columnph {\\n  width: 100%;\\n  height: 20%;\\n  bottom: 0;\\n  left: 0; }\\n  .columnph.tilewrapper-enter {\\n    height: 0%;\\n    opacity: 0; }\\n    .columnph.tilewrapper-enter.tilewrapper-enter-active {\\n      height: 20%;\\n      opacity: 1; }\\n  .columnph.tilewrapper-leave {\\n    height: 0%;\\n    opacity: 0; }\\n\", \"\"]);\n\n// exports\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader!./~/postcss-loader!./~/sass-loader!./src/tiles.scss\n ** module id = 27\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/tiles.scss?./~/css-loader!./~/postcss-loader!./~/sass-loader");

/***/ },
/* 28 */
/***/ function(module, exports) {

	eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader/lib/css-base.js\n ** module id = 28\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/css-loader/lib/css-base.js?");

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n\tmemoize = function(fn) {\r\n\t\tvar memo;\r\n\t\treturn function () {\r\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\treturn memo;\r\n\t\t};\r\n\t},\r\n\tisOldIE = memoize(function() {\r\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t}),\r\n\tgetHeadElement = memoize(function () {\r\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t}),\r\n\tsingletonElement = null,\r\n\tsingletonCounter = 0,\r\n\tstyleElementsInsertedAtTop = [];\r\n\r\nmodule.exports = function(list, options) {\r\n\tif(false) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\r\n\t// By default, add <style> tags to the bottom of <head>.\r\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction insertStyleElement(options, styleElement) {\r\n\tvar head = getHeadElement();\r\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\tif (options.insertAt === \"top\") {\r\n\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t} else {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t}\r\n\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t} else if (options.insertAt === \"bottom\") {\r\n\t\thead.appendChild(styleElement);\r\n\t} else {\r\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t}\r\n}\r\n\r\nfunction removeStyleElement(styleElement) {\r\n\tstyleElement.parentNode.removeChild(styleElement);\r\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\tif(idx >= 0) {\r\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t}\r\n}\r\n\r\nfunction createStyleElement(options) {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tstyleElement.type = \"text/css\";\r\n\tinsertStyleElement(options, styleElement);\r\n\treturn styleElement;\r\n}\r\n\r\nfunction createLinkElement(options) {\r\n\tvar linkElement = document.createElement(\"link\");\r\n\tlinkElement.rel = \"stylesheet\";\r\n\tinsertStyleElement(options, linkElement);\r\n\treturn linkElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n\tvar styleElement, update, remove;\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t} else if(obj.sourceMap &&\r\n\t\ttypeof URL === \"function\" &&\r\n\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\ttypeof Blob === \"function\" &&\r\n\t\ttypeof btoa === \"function\") {\r\n\t\tstyleElement = createLinkElement(options);\r\n\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t\tif(styleElement.href)\r\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t};\r\n\t} else {\r\n\t\tstyleElement = createStyleElement(options);\r\n\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\treturn;\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nvar replaceText = (function () {\r\n\tvar textStore = [];\r\n\r\n\treturn function (index, replacement) {\r\n\t\ttextStore[index] = replacement;\r\n\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t};\r\n})();\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = styleElement.childNodes;\r\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n\r\nfunction updateLink(linkElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(sourceMap) {\r\n\t\t// http://stackoverflow.com/a/26603875\r\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t}\r\n\r\n\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\r\n\tvar oldSrc = linkElement.href;\r\n\r\n\tlinkElement.href = URL.createObjectURL(blob);\r\n\r\n\tif(oldSrc)\r\n\t\tURL.revokeObjectURL(oldSrc);\r\n}\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/style-loader/addStyles.js\n ** module id = 29\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/style-loader/addStyles.js?");

/***/ }
/******/ ])
});
;